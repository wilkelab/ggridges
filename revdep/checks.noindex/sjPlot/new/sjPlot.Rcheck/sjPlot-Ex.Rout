
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "sjPlot"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('sjPlot')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("dist_chisq")
> ### * dist_chisq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_chisq
> ### Title: Plot chi-squared distributions
> ### Aliases: dist_chisq
> 
> ### ** Examples
> 
> # a simple chi-squared distribution
> # for 6 degrees of freedom
> dist_chisq(deg.f = 6)
> 
> # a chi-squared distribution for 6 degrees of freedom,
> # and a shaded area starting at chi-squared value of ten.
> # With a df of 6, a chi-squared value of 12.59 would be "significant",
> # thus the shaded area from 10 to 12.58 is filled as "non-significant",
> # while the area starting from chi-squared value 12.59 is filled as
> # "significant"
> dist_chisq(chi2 = 10, deg.f = 6)
> 
> # a chi-squared distribution for 6 degrees of freedom,
> # and a shaded area starting at that chi-squared value, which has
> # a p-level of about 0.125 (which equals a chi-squared value of about 10).
> # With a df of 6, a chi-squared value of 12.59 would be "significant",
> # thus the shaded area from 10 to 12.58 (p-level 0.125 to p-level 0.05)
> # is filled as "non-significant", while the area starting from chi-squared
> # value 12.59 (p-level < 0.05) is filled as "significant".
> dist_chisq(p = 0.125, deg.f = 6)
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_f")
> ### * dist_f
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_f
> ### Title: Plot F distributions
> ### Aliases: dist_f
> 
> ### ** Examples
> 
> # a simple F distribution for 6 and 45 degrees of freedom
> dist_f(deg.f1 = 6, deg.f2 = 45)
> 
> # F distribution for 6 and 45 degrees of freedom,
> # and a shaded area starting at F value of two.
> # F-values equal or greater than 2.31 are "significant"
> dist_f(f = 2, deg.f1 = 6, deg.f2 = 45)
> 
> # F distribution for 6 and 45 degrees of freedom,
> # and a shaded area starting at a p-level of 0.2
> # (F-Value about 1.5).
> dist_f(p = 0.2, deg.f1 = 6, deg.f2 = 45)
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_norm")
> ### * dist_norm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_norm
> ### Title: Plot normal distributions
> ### Aliases: dist_norm
> 
> ### ** Examples
> 
> # a simple normal distribution
> dist_norm()
> 
> # a simple normal distribution with different mean and sd.
> # note that curve looks similar to above plot, but axis range
> # has changed.
> dist_norm(mean = 2, sd = 4)
> 
> # a simple normal distribution
> dist_norm(norm = 1)
> 
> # a simple normal distribution
> dist_norm(p = 0.2)
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_t")
> ### * dist_t
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_t
> ### Title: Plot t-distributions
> ### Aliases: dist_t
> 
> ### ** Examples
> 
> # a simple t-distribution
> # for 6 degrees of freedom
> dist_t(deg.f = 6)
> 
> # a t-distribution for 6 degrees of freedom,
> # and a shaded area starting at t-value of one.
> # With a df of 6, a t-value of 1.94 would be "significant".
> dist_t(t = 1, deg.f = 6)
> 
> # a t-distribution for 6 degrees of freedom,
> # and a shaded area starting at p-level of 0.4
> # (t-value of about 0.26).
> dist_t(p = 0.4, deg.f = 6)
> 
> 
> 
> 
> cleanEx()
> nameEx("plot_frq")
> ### * plot_frq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_frq
> ### Title: Plot frequencies of variables
> ### Aliases: plot_frq
> 
> ### ** Examples
> 
> library(sjlabelled)
> data(efc)
> data(iris)
> 
> # simple plots, two different notations
> plot_frq(iris, Species)
> plot_frq(efc$tot_sc_e)
> 
> # boxplot
> plot_frq(efc$e17age, type = "box")
Warning: The `fun.y` argument of `stat_summary()` is deprecated as of ggplot2 3.3.0.
ℹ Please use the `fun` argument instead.
ℹ The deprecated feature was likely used in the sjPlot package.
  Please report the issue at <https://github.com/strengejacke/sjPlot/issues>.
> 
> if (require("dplyr")) {
+   # histogram, pipe-workflow
+   efc %>%
+     dplyr::select(e17age, c160age) %>%
+     plot_frq(type = "hist", show.mean = TRUE)
+ 
+   # bar plot(s)
+   plot_frq(efc, e42dep, c172code)
+ }
Loading required package: dplyr

Attaching package: ‘dplyr’

The following object is masked from ‘package:sjlabelled’:

    as_label

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

[[1]]

[[2]]

> 
> if (require("dplyr") && require("gridExtra")) {
+   # grouped data frame, all panels in one plot
+   efc %>%
+     group_by(e42dep) %>%
+     plot_frq(c161sex) %>%
+     plot_grid()
+ }
Loading required package: gridExtra

Attaching package: ‘gridExtra’

The following object is masked from ‘package:dplyr’:

    combine

Warning in plot_grid(.) :
  Not enough tags labels in list. Using letters instead.
> 
> 
> 
> 
> cleanEx()

detaching ‘package:gridExtra’, ‘package:dplyr’, ‘package:sjlabelled’

> nameEx("plot_gpt")
> ### * plot_gpt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_gpt
> ### Title: Plot grouped proportional tables
> ### Aliases: plot_gpt
> 
> ### ** Examples
> 
> if (requireNamespace("haven")) {
+   data(efc)
+ 
+   # the proportion of dependency levels in female
+   # elderly, for each family carer's relationship
+   # to elderly
+   plot_gpt(efc, e42dep, e16sex, e15relat)
+ 
+   # proportion of educational levels in highest
+   # dependency category of elderly, for different
+   # care levels
+   plot_gpt(efc, c172code, e42dep, n4pstu)
+ }
> 
> 
> 
> cleanEx()
> nameEx("plot_grid")
> ### * plot_grid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_grid
> ### Title: Arrange list of plots as grid
> ### Aliases: plot_grid
> 
> ### ** Examples
> 
> if (require("dplyr") && require("gridExtra")) {
+   library(ggeffects)
+   data(efc)
+ 
+   # fit model
+   fit <- glm(
+     tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7,
+     data = efc,
+     family = poisson
+   )
+ 
+   # plot marginal effects for each predictor, each as single plot
+   p1 <- ggpredict(fit, "c12hour") %>%
+     plot(show.y.title = FALSE, show.title = FALSE)
+   p2 <- ggpredict(fit, "e17age") %>%
+     plot(show.y.title = FALSE, show.title = FALSE)
+   p3 <- ggpredict(fit, "e42dep") %>%
+     plot(show.y.title = FALSE, show.title = FALSE)
+   p4 <- ggpredict(fit, "neg_c_7") %>%
+     plot(show.y.title = FALSE, show.title = FALSE)
+ 
+   # plot grid
+   plot_grid(list(p1, p2, p3, p4))
+ 
+   # plot grid
+   plot_grid(list(p1, p2, p3, p4), tags = TRUE)
+ }
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Loading required package: gridExtra

Attaching package: ‘gridExtra’

The following object is masked from ‘package:dplyr’:

    combine

Warning in plot_grid(list(p1, p2, p3, p4)) :
  Not enough tags labels in list. Using letters instead.
> 
> 
> 
> cleanEx()

detaching ‘package:ggeffects’, ‘package:gridExtra’, ‘package:dplyr’

> nameEx("plot_grpfrq")
> ### * plot_grpfrq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_grpfrq
> ### Title: Plot grouped or stacked frequencies
> ### Aliases: plot_grpfrq
> 
> ### ** Examples
> 
> data(efc)
> plot_grpfrq(efc$e17age, efc$e16sex, show.values = FALSE)
> 
> # boxplot
> plot_grpfrq(efc$e17age, efc$e42dep, type = "box")
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
> 
> # grouped bars
> plot_grpfrq(efc$e42dep, efc$e16sex, title = NULL)
> 
> # box plots with interaction variable
> plot_grpfrq(efc$e17age, efc$e42dep, intr.var = efc$e16sex, type = "box")
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
> 
> # Grouped bar plot
> plot_grpfrq(efc$neg_c_7, efc$e42dep, show.values = FALSE)
> 
> # same data as line plot
> plot_grpfrq(efc$neg_c_7, efc$e42dep, type = "line")
> 
> # show ony categories where we have data (i.e. drop zero-counts)
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> efc <- dplyr::filter(efc, e42dep %in% c(3,4))
> plot_grpfrq(efc$c161sex, efc$e42dep, drop.empty = TRUE)
> 
> # show all categories, even if not in data
> plot_grpfrq(efc$c161sex, efc$e42dep, drop.empty = FALSE)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("plot_kfold_cv")
> ### * plot_kfold_cv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_kfold_cv
> ### Title: Plot model fit from k-fold cross-validation
> ### Aliases: plot_kfold_cv
> 
> ### ** Examples
> 
> data(efc)
> 
> plot_kfold_cv(efc, neg_c_7 ~ e42dep + c172code + c12hour)
`geom_smooth()` using formula = 'y ~ x'
Warning: Removed 119 rows containing non-finite values (`stat_smooth()`).
Warning: Removed 119 rows containing missing values (`geom_point()`).
> plot_kfold_cv(mtcars, mpg ~.)
`geom_smooth()` using formula = 'y ~ x'
> 
> # for poisson models. need to fit a model and use 'fit'-argument
> fit <- glm(tot_sc_e ~ neg_c_7 + c172code, data = efc, family = poisson)
> plot_kfold_cv(efc, fit = fit)
`geom_smooth()` using formula = 'y ~ x'
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  pseudoinverse used at -0.045
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  neighborhood radius 1.045
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  reciprocal condition number  2.1867e-29
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  There are other near singularities as well. 1
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  pseudoinverse used at -0.045
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  neighborhood radius 1.045
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  reciprocal condition number  2.1867e-29
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  There are other near singularities as well. 1
> 
> # and for negative binomial models
> fit <- MASS::glm.nb(tot_sc_e ~ neg_c_7 + c172code, data = efc)
> plot_kfold_cv(efc, fit = fit)
`geom_smooth()` using formula = 'y ~ x'
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  pseudoinverse used at -0.045
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  neighborhood radius 1.045
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  reciprocal condition number  1.4565e-28
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  There are other near singularities as well. 1
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  pseudoinverse used at -0.045
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  neighborhood radius 1.045
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  reciprocal condition number  1.4565e-28
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  There are other near singularities as well. 1
> 
> 
> 
> 
> cleanEx()
> nameEx("plot_likert")
> ### * plot_likert
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_likert
> ### Title: Plot likert scales as centered stacked bars
> ### Aliases: plot_likert
> 
> ### ** Examples
> 
> if (requireNamespace("ggrepel") && requireNamespace("sjmisc")) {
+ library(sjmisc)
+ data(efc)
+ # find all variables from COPE-Index, which all have a "cop" in their
+ # variable name, and then plot that subset as likert-plot
+ mydf <- find_var(efc, pattern = "cop", out = "df")
+ 
+ plot_likert(mydf)
+ 
+ plot_likert(
+   mydf,
+   grid.range = c(1.2, 1.4),
+   expand.grid = FALSE,
+   values = "sum.outside",
+   show.prc.sign = TRUE
+ )
+ 
+ # Plot in groups
+ 
+ plot_likert(mydf, c(2,1,1,1,1,2,2,2,1))
+ 
+ if (require("parameters") && require("nFactors")) {
+   groups <- parameters::principal_components(mydf)
+   plot_likert(mydf, groups = parameters::closest_component(groups))
+ }
+ 
+ plot_likert(mydf,
+             c(rep("B", 4), rep("A", 5)),
+             sort.groups = FALSE,
+             grid.range = c(0.9, 1.1),
+             geom.colors = "RdBu",
+             rel_heights = c(6, 8),
+             wrap.labels = 40,
+             reverse.scale = TRUE)
+ 
+ # control legend items
+ six_cat_example = data.frame(
+   matrix(sample(1:6, 600, replace = TRUE),
+   ncol = 6)
+ )
+ 
+ ## Not run: 
+ ##D six_cat_example <-
+ ##D   six_cat_example %>%
+ ##D   dplyr::mutate_all(~ordered(.,labels = c("+++","++","+","-","--","---")))
+ ##D 
+ ##D # Old default
+ ##D plot_likert(
+ ##D   six_cat_example,
+ ##D   groups = c(1, 1, 1, 2, 2, 2),
+ ##D   group.legend.options = list(nrow = 2, byrow = FALSE)
+ ##D )
+ ##D 
+ ##D # New default
+ ##D plot_likert(six_cat_example, groups = c(1, 1, 1, 2, 2, 2))
+ ##D 
+ ##D # Single row
+ ##D plot_likert(
+ ##D   six_cat_example,
+ ##D   groups = c(1, 1, 1, 2, 2, 2),
+ ##D   group.legend.options = list(nrow = 1)
+ ##D )
+ ## End(Not run)
+ }
Loading required namespace: ggrepel
Loading required package: parameters
Loading required package: nFactors
Loading required package: lattice

Attaching package: ‘nFactors’

The following object is masked from ‘package:lattice’:

    parallel

> 
> 
> 
> cleanEx()

detaching ‘package:nFactors’, ‘package:lattice’, ‘package:parameters’,
  ‘package:sjmisc’

> nameEx("plot_model")
> ### * plot_model
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_model
> ### Title: Plot regression models
> ### Aliases: plot_model get_model_data
> 
> ### ** Examples
> 
> # prepare data
> if (requireNamespace("haven")) {
+ library(sjmisc)
+ data(efc)
+ efc <- to_factor(efc, c161sex, e42dep, c172code)
+ m <- lm(neg_c_7 ~ pos_v_4 + c12hour + e42dep + c172code, data = efc)
+ 
+ # simple forest plot
+ plot_model(m)
+ 
+ # grouped coefficients
+ plot_model(m, group.terms = c(1, 2, 3, 3, 3, 4, 4))
+ 
+ # keep only selected terms in the model: pos_v_4, the
+ # levels 3 and 4 of factor e42dep and levels 2 and 3 for c172code
+ plot_model(m, terms = c("pos_v_4", "e42dep [3,4]", "c172code [2,3]"))
+ }
> 
> # multiple plots, as returned from "diagnostic"-plot type,
> # can be arranged with 'plot_grid()'
> ## Not run: 
> ##D p <- plot_model(m, type = "diag")
> ##D plot_grid(p)
> ## End(Not run)
> 
> # plot random effects
> if (require("lme4") && require("glmmTMB")) {
+   m <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
+   plot_model(m, type = "re")
+ 
+   # plot marginal effects
+   plot_model(m, type = "pred", terms = "Days")
+ }
Loading required package: lme4
Loading required package: Matrix
Loading required package: glmmTMB
Warning in checkDepPackageVersion(dep_pkg = "TMB") :
  Package version inconsistency detected.
glmmTMB was built with TMB version 1.9.6
Current TMB version is 1.9.10
Please re-install glmmTMB from source or restore original ‘TMB’ package (see '?reinstalling' for more information)
> # plot interactions
> ## Not run: 
> ##D m <- glm(
> ##D   tot_sc_e ~ c161sex + c172code * neg_c_7,
> ##D   data = efc,
> ##D   family = poisson()
> ##D )
> ##D # type = "int" automatically selects groups for continuous moderator
> ##D # variables - see argument 'mdrt.values'. The following function call is
> ##D # identical to:
> ##D # plot_model(m, type = "pred", terms = c("c172code", "neg_c_7 [7,28]"))
> ##D plot_model(m, type = "int")
> ##D 
> ##D # switch moderator
> ##D plot_model(m, type = "pred", terms = c("neg_c_7", "c172code"))
> ##D # same as
> ##D # ggeffects::ggpredict(m, terms = c("neg_c_7", "c172code"))
> ## End(Not run)
> 
> # plot Stan-model
> ## Not run: 
> ##D if (require("rstanarm")) {
> ##D   data(mtcars)
> ##D   m <- stan_glm(mpg ~ wt + am + cyl + gear, data = mtcars, chains = 1)
> ##D   plot_model(m, bpe.style = "dot")
> ##D }
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:glmmTMB’, ‘package:lme4’, ‘package:Matrix’,
  ‘package:sjmisc’

> nameEx("plot_models")
> ### * plot_models
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_models
> ### Title: Forest plot of multiple regression models
> ### Aliases: plot_models
> 
> ### ** Examples
> 
> data(efc)
> 
> # fit three models
> fit1 <- lm(barthtot ~ c160age + c12hour + c161sex + c172code, data = efc)
> fit2 <- lm(neg_c_7 ~ c160age + c12hour + c161sex + c172code, data = efc)
> fit3 <- lm(tot_sc_e ~ c160age + c12hour + c161sex + c172code, data = efc)
> 
> # plot multiple models
> plot_models(fit1, fit2, fit3, grid = TRUE)
> 
> # plot multiple models with legend labels and
> # point shapes instead of value labels
> plot_models(
+   fit1, fit2, fit3,
+   axis.labels = c(
+     "Carer's Age", "Hours of Care", "Carer's Sex", "Educational Status"
+   ),
+   m.labels = c("Barthel Index", "Negative Impact", "Services used"),
+   show.values = FALSE, show.p = FALSE, p.shape = TRUE
+ )
> 
> ## Not run: 
> ##D # plot multiple models from nested lists argument
> ##D all.models <- list()
> ##D all.models[[1]] <- fit1
> ##D all.models[[2]] <- fit2
> ##D all.models[[3]] <- fit3
> ##D 
> ##D plot_models(all.models)
> ##D 
> ##D # plot multiple models with different predictors (stepwise inclusion),
> ##D # standardized estimates
> ##D fit1 <- lm(mpg ~ wt + cyl + disp + gear, data = mtcars)
> ##D fit2 <- update(fit1, . ~ . + hp)
> ##D fit3 <- update(fit2, . ~ . + am)
> ##D 
> ##D plot_models(fit1, fit2, fit3, std.est = "std2")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("plot_residuals")
> ### * plot_residuals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_residuals
> ### Title: Plot predicted values and their residuals
> ### Aliases: plot_residuals
> 
> ### ** Examples
> 
> data(efc)
> # fit model
> fit <- lm(neg_c_7 ~ c12hour + e17age + e42dep, data = efc)
> 
> # plot residuals for all independent variables
> plot_residuals(fit)
`geom_smooth()` using formula = 'y ~ x'
> 
> # remove some independent variables from output
> plot_residuals(fit, remove.estimates = c("e17age", "e42dep"))
`geom_smooth()` using formula = 'y ~ x'
> 
> 
> 
> 
> cleanEx()
> nameEx("plot_scatter")
> ### * plot_scatter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_scatter
> ### Title: Plot (grouped) scatter plots
> ### Aliases: plot_scatter
> 
> ### ** Examples
> 
> # load sample date
> library(sjmisc)
> library(sjlabelled)
> data(efc)
> 
> # simple scatter plot
> plot_scatter(efc, e16sex, neg_c_7)
> 
> # simple scatter plot, increased jittering
> plot_scatter(efc, e16sex, neg_c_7, jitter = .4)
> 
> # grouped scatter plot
> plot_scatter(efc, c160age, e17age, e42dep)
> 
> # grouped scatter plot with marginal rug plot
> # and add fitted line for complete data
> plot_scatter(
+   efc, c12hour, c160age, c172code,
+   show.rug = TRUE, fit.line = "lm"
+ )
`geom_smooth()` using formula = 'y ~ x'
> 
> # grouped scatter plot with marginal rug plot
> # and add fitted line for each group
> plot_scatter(
+   efc, c12hour, c160age, c172code,
+   show.rug = TRUE, fit.grps = "loess",
+   grid = TRUE
+ )
`geom_smooth()` using formula = 'y ~ x'
> 
> 
> 
> 
> cleanEx()

detaching ‘package:sjlabelled’, ‘package:sjmisc’

> nameEx("plot_stackfrq")
> ### * plot_stackfrq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_stackfrq
> ### Title: Plot stacked proportional bars
> ### Aliases: plot_stackfrq
> 
> ### ** Examples
> 
> # Data from the EUROFAMCARE sample dataset
> library(sjmisc)
> data(efc)
> # recveive first item of COPE-index scale
> start <- which(colnames(efc) == "c82cop1")
> # recveive first item of COPE-index scale
> end <- which(colnames(efc) == "c90cop9")
> # auto-detection of labels
> plot_stackfrq(efc[, start:end])
> 
> # works on grouped data frames as well
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> efc %>%
+   group_by(c161sex) %>%
+   select(start:end) %>%
+   plot_stackfrq()
Warning: Using an external vector in selections was deprecated in tidyselect 1.1.0.
ℹ Please use `all_of()` or `any_of()` instead.
  # Was:
  data %>% select(start)

  # Now:
  data %>% select(all_of(start))

See <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.
Warning: Using an external vector in selections was deprecated in tidyselect 1.1.0.
ℹ Please use `all_of()` or `any_of()` instead.
  # Was:
  data %>% select(end)

  # Now:
  data %>% select(all_of(end))

See <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.
Adding missing grouping variables: `c161sex`
[[1]]
[[1]][[1]]
NULL

[[1]][[2]]


[[2]]

> 
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘package:sjmisc’

> nameEx("plot_xtab")
> ### * plot_xtab
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_xtab
> ### Title: Plot contingency tables
> ### Aliases: plot_xtab
> 
> ### ** Examples
> 
> # create 4-category-items
> grp <- sample(1:4, 100, replace = TRUE)
> # create 3-category-items
> x <- sample(1:3, 100, replace = TRUE)
> 
> # plot "cross tablulation" of x and grp
> plot_xtab(x, grp)
> 
> # plot "cross tablulation" of x and y, including labels
> plot_xtab(x, grp, axis.labels = c("low", "mid", "high"),
+          legend.labels = c("Grp 1", "Grp 2", "Grp 3", "Grp 4"))
> 
> # plot "cross tablulation" of x and grp
> # as stacked proportional bars
> plot_xtab(x, grp, margin = "row", bar.pos = "stack",
+          show.summary = TRUE, coord.flip = TRUE)
> 
> # example with vertical labels
> library(sjmisc)
> library(sjlabelled)
> data(efc)
> set_theme(geom.label.angle = 90)
> plot_xtab(efc$e42dep, efc$e16sex, vjust = "center", hjust = "bottom")
> 
> # grouped bars with EUROFAMCARE sample dataset
> # dataset was importet from an SPSS-file,
> # see ?sjmisc::read_spss
> data(efc)
> efc.val <- get_labels(efc)
> efc.var <- get_label(efc)
> 
> plot_xtab(efc$e42dep, efc$e16sex, title = efc.var['e42dep'],
+          axis.labels = efc.val[['e42dep']], legend.title = efc.var['e16sex'],
+          legend.labels = efc.val[['e16sex']])
> 
> plot_xtab(efc$e16sex, efc$e42dep, title = efc.var['e16sex'],
+          axis.labels = efc.val[['e16sex']], legend.title = efc.var['e42dep'],
+          legend.labels = efc.val[['e42dep']])
> 
> # -------------------------------
> # auto-detection of labels works here
> # so no need to specify labels. For
> # title-auto-detection, use NULL
> # -------------------------------
> plot_xtab(efc$e16sex, efc$e42dep, title = NULL)
> 
> plot_xtab(efc$e16sex, efc$e42dep, margin = "row",
+          bar.pos = "stack", coord.flip = TRUE)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:sjlabelled’, ‘package:sjmisc’

> nameEx("set_theme")
> ### * set_theme
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_theme
> ### Title: Set global theme options for sjp-functions
> ### Aliases: set_theme
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(sjmisc)
> ##D data(efc)
> ##D # set sjPlot-defaults, a slightly modification
> ##D # of the ggplot base theme
> ##D set_theme()
> ##D 
> ##D # legends of all plots inside
> ##D set_theme(legend.pos = "top left", legend.inside = TRUE)
> ##D plot_xtab(efc$e42dep, efc$e16sex)
> ##D 
> ##D # Use classic-theme. you may need to
> ##D # load the ggplot2-library.
> ##D library(ggplot2)
> ##D set_theme(base = theme_classic())
> ##D plot_frq(efc$e42dep)
> ##D 
> ##D # adjust value labels
> ##D set_theme(
> ##D   geom.label.size = 3.5,
> ##D   geom.label.color = "#3366cc",
> ##D   geom.label.angle = 90
> ##D )
> ##D 
> ##D # hjust-aes needs adjustment for this
> ##D update_geom_defaults('text', list(hjust = -0.1))
> ##D plot_xtab(efc$e42dep, efc$e16sex, vjust = "center", hjust = "center")
> ##D 
> ##D # Create own theme based on classic-theme
> ##D set_theme(
> ##D   base = theme_classic(), axis.linecolor = "grey50",
> ##D   axis.textcolor = "#6699cc"
> ##D )
> ##D plot_frq(efc$e42dep)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("sjPlot-themes")
> ### * sjPlot-themes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sjPlot-themes
> ### Title: Modify plot appearance
> ### Aliases: sjPlot-themes theme_sjplot theme_sjplot2 theme_blank theme_538
> ###   font_size label_angle legend_style scale_color_sjplot
> ###   scale_fill_sjplot sjplot_pal show_sjplot_pals css_theme
> 
> ### ** Examples
> 
> # prepare data
> if (requireNamespace("haven")) {
+ library(sjmisc)
+ data(efc)
+ efc <- to_factor(efc, c161sex, e42dep, c172code)
+ m <- lm(neg_c_7 ~ pos_v_4 + c12hour + e42dep + c172code, data = efc)
+ 
+ # create plot-object
+ p <- plot_model(m)
+ 
+ # change theme
+ p + theme_sjplot()
+ 
+ # change font-size
+ p + font_size(axis_title.x = 30)
+ 
+ # apply color theme
+ p + scale_color_sjplot()
+ 
+ # show all available colour palettes
+ show_sjplot_pals()
+ 
+ # get colour values from specific palette
+ sjplot_pal(pal = "breakfast club")
+ }
Scale for colour is already present.
Adding another scale for colour, which will replace the existing scale.
[1] "#b6411a" "#4182dd" "#2d6328" "#eec3d8" "#ecf0c8"
> 
> 
> 
> 
> cleanEx()

detaching ‘package:sjmisc’

> nameEx("sjp.aov1")
> ### * sjp.aov1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sjp.aov1
> ### Title: Plot One-Way-Anova tables
> ### Aliases: sjp.aov1
> 
> ### ** Examples
> 
> data(efc)
> # note: "var.grp" does not need to be a factor.
> # coercion to factor is done by the function
> sjp.aov1(efc$c12hour, efc$e42dep)
Warning: Continuous limits supplied to discrete scale.
ℹ Did you mean `limits = factor(...)` or `scale_*_continuous()`?
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("sjp.chi2")
> ### * sjp.chi2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sjp.chi2
> ### Title: Plot Pearson's Chi2-Test of multiple contingency tables
> ### Aliases: sjp.chi2
> 
> ### ** Examples
> 
> # create data frame with 5 dichotomous (dummy) variables
> mydf <- data.frame(as.factor(sample(1:2, 100, replace=TRUE)),
+                    as.factor(sample(1:2, 100, replace=TRUE)),
+                    as.factor(sample(1:2, 100, replace=TRUE)),
+                    as.factor(sample(1:2, 100, replace=TRUE)),
+                    as.factor(sample(1:2, 100, replace=TRUE)))
> # create variable labels
> items <- list(c("Item 1", "Item 2", "Item 3", "Item 4", "Item 5"))
> 
> # plot Chi2-contingency-table
> sjp.chi2(mydf, axis.labels = items)
> 
> 
> 
> 
> cleanEx()
> nameEx("sjp.poly")
> ### * sjp.poly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sjp.poly
> ### Title: Plot polynomials for (generalized) linear regression
> ### Aliases: sjp.poly
> 
> ### ** Examples
> 
> library(sjmisc)
> data(efc)
> # linear fit. loess-smoothed line indicates a more
> # or less cubic curve
> sjp.poly(efc$c160age, efc$quol_5, 1)
Polynomial degrees: 1
---------------------
p(x^1): 0.000

`geom_smooth()` using formula = 'y ~ x'
> 
> # quadratic fit
> sjp.poly(efc$c160age, efc$quol_5, 2)
Polynomial degrees: 2
---------------------
p(x^1): 0.078
p(x^2): 0.533

`geom_smooth()` using formula = 'y ~ x'
> 
> # linear to cubic fit
> sjp.poly(efc$c160age, efc$quol_5, 1:4, show.scatter = FALSE)
Polynomial degrees: 1
---------------------
p(x^1): 0.000

Polynomial degrees: 2
---------------------
p(x^1): 0.078
p(x^2): 0.533

Polynomial degrees: 3
---------------------
p(x^1): 0.012
p(x^2): 0.001
p(x^3): 0.000

Polynomial degrees: 4
---------------------
p(x^1): 0.777
p(x^2): 0.913
p(x^3): 0.505
p(x^4): 0.254

`geom_smooth()` using formula = 'y ~ x'
> 
> 
> # fit sample model
> fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep, data = efc)
> # inspect relationship between predictors and response
> plot_model(fit, type = "slope")
`geom_smooth()` using formula = 'y ~ x'
`geom_smooth()` using formula = 'y ~ x'
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  pseudoinverse used at 4.015
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  neighborhood radius 2.015
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  reciprocal condition number  4.4527e-15
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  There are other near singularities as well. 1
> # "e17age" does not seem to be linear correlated to response
> # try to find appropiate polynomial. Grey line (loess smoothed)
> # indicates best fit. Looks like x^4 has the best fit,
> # however, only x^3 has significant p-values.
> sjp.poly(fit, "e17age", 2:4, show.scatter = FALSE)
Polynomial degrees: 2
---------------------
p(x^1): 0.734
p(x^2): 0.721

Polynomial degrees: 3
---------------------
p(x^1): 0.010
p(x^2): 0.011
p(x^3): 0.011

Polynomial degrees: 4
---------------------
p(x^1): 0.234
p(x^2): 0.267
p(x^3): 0.303
p(x^4): 0.343

`geom_smooth()` using formula = 'y ~ x'
> 
> ## Not run: 
> ##D # fit new model
> ##D fit <- lm(tot_sc_e ~ c12hour + e42dep + e17age + I(e17age^2) + I(e17age^3),
> ##D           data = efc)
> ##D # plot marginal effects of polynomial term
> ##D plot_model(fit, type = "pred", terms = "e17age")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:sjmisc’

> nameEx("sjplot")
> ### * sjplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sjplot
> ### Title: Wrapper to create plots and tables within a pipe-workflow
> ### Aliases: sjplot sjtab
> 
> ### ** Examples
> 
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> data(efc)
> 
> # Grouped frequencies
> efc %>% sjplot(e42dep, c172code, fun = "grpfrq")
> 
> # Grouped frequencies, as box plots
> efc %>% sjplot(e17age, c172code, fun = "grpfrq",
+                type = "box", geom.colors = "Set1")
> 
> ## Not run: 
> ##D # table output of grouped data frame
> ##D efc %>%
> ##D   group_by(e16sex, c172code) %>%
> ##D   select(e42dep, n4pstu, e16sex, c172code) %>%
> ##D   sjtab(fun = "xtab", use.viewer = FALSE) # open all tables in browser
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("tab_corr")
> ### * tab_corr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_corr
> ### Title: Summary of correlations as HTML table
> ### Aliases: tab_corr
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (interactive()) {
> ##D   # Data from the EUROFAMCARE sample dataset
> ##D   library(sjmisc)
> ##D   data(efc)
> ##D 
> ##D   # retrieve variable and value labels
> ##D   varlabs <- get_label(efc)
> ##D 
> ##D   # recveive first item of COPE-index scale
> ##D   start <- which(colnames(efc) == "c83cop2")
> ##D   # recveive last item of COPE-index scale
> ##D   end <- which(colnames(efc) == "c88cop7")
> ##D 
> ##D   # create data frame with COPE-index scale
> ##D   mydf <- data.frame(efc[, c(start:end)])
> ##D   colnames(mydf) <- varlabs[c(start:end)]
> ##D 
> ##D   # we have high correlations here, because all items
> ##D   # belong to one factor.
> ##D   tab_corr(mydf, p.numeric = TRUE)
> ##D 
> ##D   # auto-detection of labels, only lower triangle
> ##D   tab_corr(efc[, c(start:end)], triangle = "lower")
> ##D 
> ##D   # auto-detection of labels, only lower triangle, all correlation
> ##D   # values smaller than 0.3 are not shown in the table
> ##D   tab_corr(efc[, c(start:end)], triangle = "lower", val.rm = 0.3)
> ##D 
> ##D   # auto-detection of labels, only lower triangle, all correlation
> ##D   # values smaller than 0.3 are printed in blue
> ##D   tab_corr(efc[, c(start:end)], triangle = "lower",val.rm = 0.3,
> ##D            CSS = list(css.valueremove = 'color:blue;'))
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tab_df")
> ### * tab_df
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_df
> ### Title: Print data frames as HTML table.
> ### Aliases: tab_df tab_dfs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(iris)
> ##D data(mtcars)
> ##D tab_df(iris[1:5, ])
> ##D tab_dfs(list(iris[1:5, ], mtcars[1:5, 1:5]))
> ##D 
> ##D # sort 2nd column ascending
> ##D tab_df(iris[1:5, ], sort.column = 2)
> ##D 
> ##D # sort 2nd column descending
> ##D tab_df(iris[1:5, ], sort.column = -2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("tab_fa")
> ### * tab_fa
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_fa
> ### Title: Summary of factor analysis as HTML table
> ### Aliases: tab_fa
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Data from the EUROFAMCARE sample dataset
> ##D library(sjmisc)
> ##D library(GPArotation)
> ##D data(efc)
> ##D 
> ##D # recveive first item of COPE-index scale
> ##D start <- which(colnames(efc) == "c82cop1")
> ##D # recveive last item of COPE-index scale
> ##D end <- which(colnames(efc) == "c90cop9")
> ##D # auto-detection of labels
> ##D if (interactive()) {
> ##D   tab_fa(efc[, start:end])
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tab_itemscale")
> ### * tab_itemscale
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_itemscale
> ### Title: Summary of item analysis of an item scale as HTML table
> ### Aliases: tab_itemscale sjt.itemanalysis
> 
> ### ** Examples
> 
> # Data from the EUROFAMCARE sample dataset
> library(sjmisc)
> library(sjlabelled)
> data(efc)
> 
> # retrieve variable and value labels
> varlabs <- get_label(efc)
> 
> # recveive first item of COPE-index scale
> start <- which(colnames(efc) == "c82cop1")
> # recveive last item of COPE-index scale
> end <- which(colnames(efc) == "c90cop9")
> 
> # create data frame with COPE-index scale
> mydf <- data.frame(efc[, start:end])
> colnames(mydf) <- varlabs[start:end]
> 
> ## Not run: 
> ##D if (interactive()) {
> ##D   tab_itemscale(mydf)
> ##D 
> ##D   # auto-detection of labels
> ##D   tab_itemscale(efc[, start:end])
> ##D 
> ##D   # Compute PCA on Cope-Index, and perform a
> ##D   # item analysis for each extracted factor.
> ##D   indices <- tab_pca(mydf)$factor.index
> ##D   tab_itemscale(mydf, factor.groups = indices)
> ##D 
> ##D   # or, equivalent
> ##D   tab_itemscale(mydf, factor.groups = "auto")
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching ‘package:sjlabelled’, ‘package:sjmisc’

> nameEx("tab_pca")
> ### * tab_pca
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_pca
> ### Title: Summary of principal component analysis as HTML table
> ### Aliases: tab_pca
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Data from the EUROFAMCARE sample dataset
> ##D library(sjmisc)
> ##D data(efc)
> ##D 
> ##D # recveive first item of COPE-index scale
> ##D start <- which(colnames(efc) == "c82cop1")
> ##D # recveive last item of COPE-index scale
> ##D end <- which(colnames(efc) == "c90cop9")
> ##D # auto-detection of labels
> ##D if (interactive()) {
> ##D   tab_pca(efc[, start:end])
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tab_stackfrq")
> ### * tab_stackfrq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_stackfrq
> ### Title: Summary of stacked frequencies as HTML table
> ### Aliases: tab_stackfrq
> 
> ### ** Examples
> 
> # -------------------------------
> # random sample
> # -------------------------------
> # prepare data for 4-category likert scale, 5 items
> likert_4 <- data.frame(
+   as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.2, 0.3, 0.1, 0.4))),
+   as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.5, 0.25, 0.15, 0.1))),
+   as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.25, 0.1, 0.4, 0.25))),
+   as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.1, 0.4, 0.4, 0.1))),
+   as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.35, 0.25, 0.15, 0.25)))
+ )
> 
> # create labels
> levels_4 <- c("Independent", "Slightly dependent",
+               "Dependent", "Severely dependent")
> 
> # create item labels
> items <- c("Q1", "Q2", "Q3", "Q4", "Q5")
> 
> # plot stacked frequencies of 5 (ordered) item-scales
> ## Not run: 
> ##D if (interactive()) {
> ##D   tab_stackfrq(likert_4, value.labels = levels_4, var.labels = items)
> ##D 
> ##D   # -------------------------------
> ##D   # Data from the EUROFAMCARE sample dataset
> ##D   #  Auto-detection of labels
> ##D   # -------------------------------
> ##D   data(efc)
> ##D   # recveive first item of COPE-index scale
> ##D   start <- which(colnames(efc) == "c82cop1")
> ##D   # recveive first item of COPE-index scale
> ##D   end <- which(colnames(efc) == "c90cop9")
> ##D 
> ##D   tab_stackfrq(efc[, c(start:end)], alternate.rows = TRUE)
> ##D 
> ##D   tab_stackfrq(efc[, c(start:end)], alternate.rows = TRUE,
> ##D                show.n = TRUE, show.na = TRUE)
> ##D 
> ##D   # --------------------------------
> ##D   # User defined style sheet
> ##D   # --------------------------------
> ##D   tab_stackfrq(efc[, c(start:end)], alternate.rows = TRUE,
> ##D                show.total = TRUE, show.skew = TRUE, show.kurtosis = TRUE,
> ##D                CSS = list(css.ncol = "border-left:1px dotted black;",
> ##D                           css.summary = "font-style:italic;"))
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tab_xtab")
> ### * tab_xtab
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_xtab
> ### Title: Summary of contingency tables as HTML table
> ### Aliases: tab_xtab sjt.xtab
> 
> ### ** Examples
> 
> # prepare sample data set
> data(efc)
> 
> # print simple cross table with labels
> ## Not run: 
> ##D if (interactive()) {
> ##D   tab_xtab(efc$e16sex, efc$e42dep)
> ##D 
> ##D   # print cross table with manually set
> ##D   # labels and expected values
> ##D   tab_xtab(
> ##D     efc$e16sex,
> ##D     efc$e42dep,
> ##D     var.labels = c("Elder's gender", "Elder's dependency"),
> ##D     show.exp = TRUE
> ##D   )
> ##D 
> ##D   # print minimal cross table with labels, total col/row highlighted
> ##D   tab_xtab(efc$e16sex, efc$e42dep, show.cell.prc = FALSE, emph.total = TRUE)
> ##D 
> ##D   # User defined style sheet
> ##D   tab_xtab(efc$e16sex, efc$e42dep,
> ##D            CSS = list(css.table = "border: 2px solid;",
> ##D                       css.tdata = "border: 1px solid;",
> ##D                       css.horline = "border-bottom: double blue;"))
> ##D 
> ##D   # ordinal data, use Kendall's tau
> ##D   tab_xtab(efc$e42dep, efc$quol_5, statistics = "kendall")
> ##D 
> ##D   # calculate Spearman's rho, with continuity correction
> ##D   tab_xtab(
> ##D     efc$e42dep,
> ##D     efc$quol_5,
> ##D     statistics = "spearman",
> ##D     exact = FALSE,
> ##D     continuity = TRUE
> ##D   )
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("view_df")
> ### * view_df
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: view_df
> ### Title: View structure of labelled data frames
> ### Aliases: view_df
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # init dataset
> ##D data(efc)
> ##D 
> ##D # view variables
> ##D view_df(efc)
> ##D 
> ##D # view variables w/o values and value labels
> ##D view_df(efc, show.values = FALSE, show.labels = FALSE)
> ##D 
> ##D # view variables including variable typed, orderd by name
> ##D view_df(efc, sort.by.name = TRUE, show.type = TRUE)
> ##D 
> ##D # User defined style sheet
> ##D view_df(efc,
> ##D         CSS = list(css.table = "border: 2px solid;",
> ##D                    css.tdata = "border: 1px solid;",
> ##D                    css.arc = "color:blue;"))
> ## End(Not run)
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  15.547 0.565 17.028 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')

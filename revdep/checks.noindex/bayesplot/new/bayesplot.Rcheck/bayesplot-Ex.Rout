
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "bayesplot"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('bayesplot')
This is bayesplot version 1.10.0
- Online documentation and vignettes at mc-stan.org/bayesplot
- bayesplot theme set to bayesplot::theme_default()
   * Does _not_ affect other ggplot2 plots
   * See ?bayesplot_theme_set for details on theme setting
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("MCMC-combos")
> ### * MCMC-combos
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-combos
> ### Title: Combination plots
> ### Aliases: MCMC-combos mcmc_combo
> 
> ### ** Examples
> 
> # some parameter draws to use for demonstration
> x <- example_mcmc_draws()
> dim(x)
[1] 250   4   4
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]"

> 
> mcmc_combo(x, pars = c("alpha", "sigma"))
> mcmc_combo(x, pars = c("alpha", "sigma"), widths = c(1, 2))
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-diagnostics")
> ### * MCMC-diagnostics
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-diagnostics
> ### Title: General MCMC diagnostics
> ### Aliases: MCMC-diagnostics mcmc_rhat mcmc_rhat_hist mcmc_rhat_data
> ###   mcmc_neff mcmc_neff_hist mcmc_neff_data mcmc_acf mcmc_acf_bar
> 
> ### ** Examples
> 
> # autocorrelation
> x <- example_mcmc_draws()
> dim(x)
[1] 250   4   4
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]"

> 
> color_scheme_set("green")
> mcmc_acf(x, pars = c("alpha", "beta[1]"))
Warning: The `facets` argument of `facet_grid()` is deprecated as of ggplot2 2.2.0.
ℹ Please use the `rows` argument instead.
ℹ The deprecated feature was likely used in the bayesplot package.
  Please report the issue at <https://github.com/stan-dev/bayesplot/issues/>.
> 
> # fake rhat values to use for demonstration
> rhat <- c(runif(100, 1, 1.15))
> mcmc_rhat_hist(rhat)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> mcmc_rhat(rhat)
> 
> # lollipops
> color_scheme_set("purple")
> mcmc_rhat(rhat[1:10], size = 5)
> 
> color_scheme_set("blue")
> mcmc_rhat(runif(1000, 1, 1.07))
> mcmc_rhat(runif(1000, 1, 1.3)) + legend_move("top") # add legend above plot
> 
> # fake neff ratio values to use for demonstration
> ratio <- c(runif(100, 0, 1))
> mcmc_neff_hist(ratio)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> mcmc_neff(ratio)
> 
> ## Not run: 
> ##D # Example using rstanarm model (requires rstanarm package)
> ##D library(rstanarm)
> ##D 
> ##D # intentionally use small 'iter' so there are some
> ##D # problems with rhat and neff for demonstration
> ##D fit <- stan_glm(mpg ~ ., data = mtcars, iter = 50, refresh = 0)
> ##D rhats <- rhat(fit)
> ##D ratios <- neff_ratio(fit)
> ##D mcmc_rhat(rhats)
> ##D mcmc_neff(ratios, size = 3)
> ##D 
> ##D # there's a small enough number of parameters in the
> ##D # model that we can display their names on the y-axis
> ##D mcmc_neff(ratios) + yaxis_text(hjust = 1)
> ##D 
> ##D # can also look at autocorrelation
> ##D draws <- as.array(fit)
> ##D mcmc_acf(draws, pars = c("wt", "cyl"), lags = 10)
> ##D 
> ##D # increase number of iterations and plots look much better
> ##D fit2 <- update(fit, iter = 500)
> ##D mcmc_rhat(rhat(fit2))
> ##D mcmc_neff(neff_ratio(fit2))
> ##D mcmc_acf(as.array(fit2), pars = c("wt", "cyl"), lags = 10)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-distributions")
> ### * MCMC-distributions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-distributions
> ### Title: Histograms and kernel density plots of MCMC draws
> ### Aliases: MCMC-distributions mcmc_hist mcmc_dens mcmc_hist_by_chain
> ###   mcmc_dens_overlay mcmc_dens_chains mcmc_dens_chains_data mcmc_violin
> 
> ### ** Examples
> 
> set.seed(9262017)
> # some parameter draws to use for demonstration
> x <- example_mcmc_draws()
> dim(x)
[1] 250   4   4
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]"

> 
> ##################
> ### Histograms ###
> ##################
> 
> # histograms of all parameters
> color_scheme_set("brightblue")
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # histograms of some parameters
> color_scheme_set("pink")
> mcmc_hist(x, pars = c("alpha", "beta[2]"))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> # example of using 'transformations' argument to plot log(sigma),
> # and parsing facet labels (e.g. to get greek letters for parameters)
> mcmc_hist(x, transformations = list(sigma = "log"),
+           facet_args = list(labeller = ggplot2::label_parsed)) +
+           facet_text(size = 15)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> #################
> ### Densities ###
> #################
> 
> mcmc_dens(x, pars = c("sigma", "beta[2]"),
+           facet_args = list(nrow = 2))
> # separate chains as violin plots
> color_scheme_set("green")
> mcmc_violin(x) + panel_bg(color = "gray20", size = 2, fill = "gray30")
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-intervals")
> ### * MCMC-intervals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-intervals
> ### Title: Plot interval estimates from MCMC draws
> ### Aliases: MCMC-intervals mcmc_intervals mcmc_areas mcmc_areas_ridges
> ###   mcmc_intervals_data mcmc_areas_data mcmc_areas_ridges_data
> 
> ### ** Examples
> 
> set.seed(9262017)
> 
> # load ggplot2 to use its functions to modify our plots
> library(ggplot2)
> 
> # some parameter draws to use for demonstration
> x <- example_mcmc_draws(params = 6)
> dim(x)
[1] 250   4   6
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]" "beta[3]" "beta[4]"

> 
> color_scheme_set("brightblue")
> mcmc_intervals(x)
> mcmc_intervals(x, pars = c("beta[1]", "beta[2]"))
> mcmc_areas(x, regex_pars = "beta\\[[1-3]\\]",  prob = 0.8) +
+  labs(
+    title = "Posterior distributions",
+    subtitle = "with medians and 80% intervals"
+  )
> 
> color_scheme_set("red")
> p <- mcmc_areas(
+    x,
+    pars = c("alpha", "beta[4]"),
+    prob = 2/3,
+    prob_outer = 0.9,
+    point_est = "mean",
+    border_size = 1.5 # make the ridgelines fatter
+ )
Warning in (function (mapping = NULL, data = NULL, stat = "identity", position = "identity",  :
  Ignoring unknown parameters: `size`
Warning in (function (mapping = NULL, data = NULL, stat = "identity", position = "identity",  :
  Ignoring unknown parameters: `size`
Warning in (function (mapping = NULL, data = NULL, stat = "identity", position = "identity",  :
  Ignoring unknown parameters: `size`
> plot(p)
> 
> 
> # Different area calculations
> b3 <- c("beta[1]", "beta[2]", "beta[3]")
> 
> mcmc_areas(x, pars = b3, area_method = "equal area") +
+   labs(
+     title = "Curves have same area",
+     subtitle = "A wide, uncertain interval is spread thin when areas are equal"
+    )
> 
> mcmc_areas(x, pars = b3, area_method = "equal height") +
+   labs(
+     title = "Curves have same maximum height",
+     subtitle = "Local curvature is clearer but more uncertain curves use more area"
+   )
> 
> mcmc_areas(x, pars = b3, area_method = "scaled height") +
+   labs(
+     title = "Same maximum heights but heights scaled by square-root",
+     subtitle = "Compromise: Local curvature is accentuated and less area is used"
+    )
> 
> 
> ## Not run: 
> ##D # example using fitted model from rstanarm package
> ##D library(rstanarm)
> ##D fit <- stan_glm(
> ##D  mpg ~ 0 + wt + factor(cyl),
> ##D  data = mtcars,
> ##D  iter = 500,
> ##D  refresh = 0
> ##D )
> ##D x <- as.matrix(fit)
> ##D 
> ##D color_scheme_set("teal")
> ##D mcmc_intervals(x, point_est = "mean", prob = 0.8, prob_outer = 0.95)
> ##D mcmc_areas(x, regex_pars = "cyl", bw = "SJ",
> ##D            rhat = rhat(fit, regex_pars = "cyl"))
> ## End(Not run)
> 
> ## Not run: 
> ##D # Example of hierarchically related parameters
> ##D # plotted with ridgelines
> ##D m <- shinystan::eight_schools@posterior_sample
> ##D mcmc_areas_ridges(m, pars = "mu", regex_pars = "theta", border_size = 0.75) +
> ##D   ggtitle("Treatment effect on eight schools (Rubin, 1981)")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’

> nameEx("MCMC-nuts")
> ### * MCMC-nuts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-nuts
> ### Title: Diagnostic plots for the No-U-Turn-Sampler (NUTS)
> ### Aliases: MCMC-nuts NUTS mcmc_nuts_acceptance mcmc_nuts_divergence
> ###   mcmc_nuts_stepsize mcmc_nuts_treedepth mcmc_nuts_energy
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(ggplot2)
> ##D library(rstanarm)
> ##D fit <- stan_glm(mpg ~ wt + am, data = mtcars, iter = 1000, refresh = 0)
> ##D np <- nuts_params(fit)
> ##D lp <- log_posterior(fit)
> ##D 
> ##D color_scheme_set("brightblue")
> ##D mcmc_nuts_acceptance(np, lp)
> ##D mcmc_nuts_acceptance(np, lp, chain = 2)
> ##D 
> ##D mcmc_nuts_divergence(np, lp)
> ##D mcmc_nuts_stepsize(np, lp)
> ##D mcmc_nuts_treedepth(np, lp)
> ##D 
> ##D color_scheme_set("red")
> ##D mcmc_nuts_energy(np)
> ##D mcmc_nuts_energy(np, merge_chains = TRUE, binwidth = .15)
> ##D mcmc_nuts_energy(np) +
> ##D  facet_wrap(~ Chain, nrow = 1) +
> ##D  coord_fixed(ratio = 150) +
> ##D  ggtitle("NUTS Energy Diagnostic")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-parcoord")
> ### * MCMC-parcoord
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-parcoord
> ### Title: Parallel coordinates plot of MCMC draws
> ### Aliases: MCMC-parcoord mcmc_parcoord mcmc_parcoord_data
> ###   parcoord_style_np
> 
> ### ** Examples
> 
> color_scheme_set("pink")
> x <- example_mcmc_draws(params = 5)
> mcmc_parcoord(x)
> mcmc_parcoord(x, regex_pars = "beta")
> 
> ## Not run: 
> ##D # Example using a Stan demo model
> ##D library(rstan)
> ##D fit <- stan_demo("eight_schools")
> ##D draws <- as.array(fit, pars = c("mu", "tau", "theta", "lp__"))
> ##D np <- nuts_params(fit)
> ##D str(np)
> ##D levels(np$Parameter)
> ##D 
> ##D color_scheme_set("brightblue")
> ##D mcmc_parcoord(draws, alpha = 0.05)
> ##D mcmc_parcoord(draws, np = np)
> ##D 
> ##D # customize appearance of divergences
> ##D color_scheme_set("darkgray")
> ##D div_style <- parcoord_style_np(div_color = "green", div_size = 0.05, div_alpha = 0.4)
> ##D mcmc_parcoord(draws, size = 0.25, alpha = 0.1,
> ##D               np = np, np_style = div_style)
> ##D 
> ##D # to use a transformation (e.g., standardizing all the variables can be helpful)
> ##D # specify the 'transformations' argument (though partial argument name
> ##D # matching means we can just use 'trans' or 'transform')
> ##D mcmc_parcoord(
> ##D   draws,
> ##D   transform = function(x) {(x - mean(x)) / sd(x)},
> ##D   size = 0.25,
> ##D   alpha = 0.1,
> ##D   np = np,
> ##D   np_style = div_style
> ##D  )
> ##D 
> ##D # mcmc_parcoord_data returns just the data in a conventient form for plotting
> ##D d <- mcmc_parcoord_data(x, np = np)
> ##D head(d)
> ##D tail(d)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-recover")
> ### * MCMC-recover
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-recover
> ### Title: Compare MCMC estimates to "true" parameter values
> ### Aliases: MCMC-recover mcmc_recover_intervals mcmc_recover_scatter
> ###   mcmc_recover_hist
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(rstanarm)
> ##D alpha <- 1; beta <- rnorm(10, 0, 3); sigma <- 2
> ##D X <- matrix(rnorm(1000), 100, 10)
> ##D y <- rnorm(100, mean = c(alpha + X %*% beta), sd = sigma)
> ##D fit <- stan_glm(y ~ ., data = data.frame(y, X), refresh = 0)
> ##D draws <- as.matrix(fit)
> ##D print(colnames(draws))
> ##D true <- c(alpha, beta, sigma)
> ##D 
> ##D mcmc_recover_intervals(draws, true)
> ##D 
> ##D # put the coefficients on X into the same batch
> ##D mcmc_recover_intervals(draws, true, batch = c(1, rep(2, 10), 1))
> ##D # equivalent
> ##D mcmc_recover_intervals(draws, true, batch = grepl("X", colnames(draws)))
> ##D # same but facets stacked vertically
> ##D mcmc_recover_intervals(draws, true,
> ##D                        batch = grepl("X", colnames(draws)),
> ##D                        facet_args = list(ncol = 1),
> ##D                        size = 3)
> ##D 
> ##D # each parameter in its own facet
> ##D mcmc_recover_intervals(draws, true, batch = 1:ncol(draws))
> ##D # same but in a different order
> ##D mcmc_recover_intervals(draws, true, batch = c(1, 3, 4, 2, 5:12))
> ##D # present as bias by centering with true values
> ##D mcmc_recover_intervals(sweep(draws, 2, true), rep(0, ncol(draws))) + hline_0()
> ##D 
> ##D 
> ##D # scatterplot of posterior means vs true values
> ##D mcmc_recover_scatter(draws, true, point_est = "mean")
> ##D 
> ##D 
> ##D # histograms of parameter draws with true value added as vertical line
> ##D color_scheme_set("brightblue")
> ##D mcmc_recover_hist(draws[, 1:4], true[1:4])
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-scatterplots")
> ### * MCMC-scatterplots
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-scatterplots
> ### Title: Scatterplots of MCMC draws
> ### Aliases: MCMC-scatterplots mcmc_scatter mcmc_hex mcmc_pairs
> ###   scatter_style_np pairs_style_np pairs_condition
> 
> ### ** Examples
> 
> library("ggplot2")
> 
> # some parameter draws to use for demonstration
> x <- example_mcmc_draws(params = 6)
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]" "beta[3]" "beta[4]"

> 
> # scatterplot of alpha vs log(sigma)
> color_scheme_set("teal")
> (p <- mcmc_scatter(x, pars = c("alpha", "sigma"),
+                   transform = list(sigma = "log")))
> p +
+   labs(
+     title = "Insert your own headline-grabbing title",
+     subtitle = "with a provocative subtitle",
+     caption = "and a controversial caption",
+     x = expression(alpha),
+     y = expression(log(sigma))
+    )
> 
> # add ellipse
> p + stat_ellipse(level = 0.9, color = "gray20", size = 1)
Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.
ℹ Please use `linewidth` instead.
> 
> # add contour
> color_scheme_set("red")
> p2 <- mcmc_scatter(x, pars = c("alpha", "sigma"), size = 3.5, alpha = 0.25)
> p2 + stat_density_2d(color = "black", size = .5)
> 
> # can also add lines/smooths
> color_scheme_set("pink")
> (p3 <- mcmc_scatter(x, pars = c("alpha", "beta[3]"), alpha = 0.25, size = 3))
> p3 + geom_smooth(method = "lm", se = FALSE, color = "gray20",
+                  size = .75, linetype = 2)
`geom_smooth()` using formula = 'y ~ x'
> 
> 
> ## Not run: 
> ##D ### Adding NUTS diagnostics to scatterplots and pairs plots
> ##D 
> ##D # examples using rstanarm package
> ##D library(rstanarm)
> ##D 
> ##D # for demonstration purposes, intentionally fit a model that
> ##D # will (almost certainly) have some divergences
> ##D fit <- stan_glm(
> ##D   mpg ~ ., data = mtcars,
> ##D   iter = 1000, refresh = 0,
> ##D   # this combo of prior and adapt_delta should lead to some divergences
> ##D   prior = hs(),
> ##D   adapt_delta = 0.9
> ##D )
> ##D posterior <- as.array(fit)
> ##D np <- nuts_params(fit)
> ##D 
> ##D # mcmc_scatter with divergences highlighted
> ##D color_scheme_set("brightblue")
> ##D mcmc_scatter(posterior, pars = c("wt", "sigma"), np = np)
> ##D 
> ##D color_scheme_set("darkgray")
> ##D div_style <- scatter_style_np(div_color = "green", div_shape = 4, div_size = 4)
> ##D mcmc_scatter(posterior, pars = c("sigma", "(Intercept)"),
> ##D              np = np, np_style = div_style)
> ##D 
> ##D # split the draws according to above/below median accept_stat__
> ##D # and show approximate location of divergences (red points)
> ##D color_scheme_set("brightblue")
> ##D mcmc_pairs(
> ##D   posterior,
> ##D   pars = c("wt", "cyl", "sigma"),
> ##D   off_diag_args = list(size = 1, alpha = 1/3),
> ##D   condition = pairs_condition(nuts = "accept_stat__"),
> ##D   np = np
> ##D )
> ##D 
> ##D # more customizations:
> ##D # - transform sigma to log(sigma)
> ##D # - median log-posterior as 'condition'
> ##D # - hex instead of scatter for off-diagonal plots
> ##D # - show points where max treedepth hit in blue
> ##D color_scheme_set("darkgray")
> ##D mcmc_pairs(
> ##D   posterior,
> ##D   pars = c("wt", "cyl", "sigma"),
> ##D   transform = list(sigma = "log"),
> ##D   off_diag_fun = "hex",
> ##D   condition = pairs_condition(nuts = "lp__"),
> ##D   lp = log_posterior(fit),
> ##D   np = np,
> ##D   np_style = pairs_style_np(div_color = "firebrick",
> ##D                             td_color = "blue",
> ##D                             td_size = 2),
> ##D   # for demonstration purposes, set max_treedepth to a value that will
> ##D   # result in at least a few max treedepth warnings
> ##D   max_treedepth = with(np, -1 + max(Value[Parameter == "treedepth__"]))
> ##D )
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’

> nameEx("MCMC-traces")
> ### * MCMC-traces
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-traces
> ### Title: Trace and rank plots of MCMC draws
> ### Aliases: MCMC-traces mcmc_trace mcmc_trace_highlight trace_style_np
> ###   mcmc_rank_overlay mcmc_rank_hist mcmc_rank_ecdf mcmc_trace_data
> 
> ### ** Examples
> 
> # some parameter draws to use for demonstration
> x <- example_mcmc_draws(chains = 4, params = 6)
> dim(x)
[1] 250   4   6
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]" "beta[3]" "beta[4]"

> 
> # trace plots of the betas
> color_scheme_set("viridis")
> mcmc_trace(x, regex_pars = "beta")
> 
> # mix color schemes
> color_scheme_set("mix-blue-red")
> mcmc_trace(x, regex_pars = "beta")
> 
> # use traditional ggplot discrete color scale
> mcmc_trace(x, pars = c("alpha", "sigma")) +
+  ggplot2::scale_color_discrete()
Scale for colour is already present.
Adding another scale for colour, which will replace the existing scale.
> 
> # zoom in on a window of iterations, increase line size,
> # add tick marks, move legend to the top, add gray background
> color_scheme_set("viridisA")
> mcmc_trace(x[,, 1:4], window = c(100, 130), size = 1) +
+   panel_bg(fill = "gray90", color = NA) +
+   legend_move("top")
> 
> # Rank-normalized histogram plots. Instead of showing how chains mix over
> # time, look at how the ranking of MCMC samples mixed between chains.
> color_scheme_set("viridisE")
> mcmc_rank_hist(x, "alpha")
> mcmc_rank_hist(x, pars = c("alpha", "sigma"), ref_line = TRUE)
> mcmc_rank_overlay(x, "alpha")
> 
> # ECDF and ECDF difference plots of the ranking of MCMC samples between chains.
> # Provide 99% simultaneous confidence intervals for the chains sampling from
> # the same distribution.
> mcmc_rank_ecdf(x, prob = 0.99)
> mcmc_rank_ecdf(x, prob = 0.99, plot_diff = TRUE)
> 
> ## Not run: 
> ##D # parse facet label text
> ##D color_scheme_set("purple")
> ##D p <- mcmc_trace(
> ##D   x,
> ##D   regex_pars = "beta\\\[[1,3]\\\]",
> ##D   facet_args = list(labeller = ggplot2::label_parsed)
> ##D )
> ##D p + facet_text(size = 15)
> ##D 
> ##D # mark first 100 draws as warmup
> ##D mcmc_trace(x, n_warmup = 100)
> ##D 
> ##D # plot as points, highlighting chain 2
> ##D color_scheme_set("brightblue")
> ##D mcmc_trace_highlight(x, pars = "sigma", highlight = 2, size = 2)
> ##D 
> ##D # for models fit using HMC/NUTS divergences can be displayed in the trace plot
> ##D library("rstanarm")
> ##D fit <- stan_glm(mpg ~ ., data = mtcars, refresh = 0,
> ##D   # next line to keep example fast and also ensure we get some divergences
> ##D                 prior = hs(), iter = 400, adapt_delta = 0.8)
> ##D 
> ##D # extract draws using as.array (instead of as.matrix) to keep
> ##D # chains separate for trace plot
> ##D posterior <- as.array(fit)
> ##D 
> ##D # for stanfit and stanreg objects use nuts_params() to get the divergences
> ##D mcmc_trace(posterior, pars = "sigma", np = nuts_params(fit))
> ##D 
> ##D color_scheme_set("viridis")
> ##D mcmc_trace(
> ##D   posterior,
> ##D   pars = c("wt", "sigma"),
> ##D   size = 0.5,
> ##D   facet_args = list(nrow = 2),
> ##D   np = nuts_params(fit),
> ##D   np_style = trace_style_np(div_color = "black", div_size = 0.5)
> ##D )
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-censoring")
> ### * PPC-censoring
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-censoring
> ### Title: PPC censoring
> ### Aliases: PPC-censoring ppc_km_overlay ppc_km_overlay_grouped
> 
> ### ** Examples
> 
> color_scheme_set("brightblue")
> y <- example_y_data()
> # For illustrative purposes, (right-)censor values y > 110:
> status_y <- as.numeric(y <= 110)
> y <- pmin(y, 110)
> # In reality, the replicated data (yrep) would be obtained from a
> # model which takes the censoring of y properly into account. Here,
> # for illustrative purposes, we simply use example_yrep_draws():
> yrep <- example_yrep_draws()
> dim(yrep)
[1] 500 434
> # With separate facets by group:
> group <- example_group_data()
> 
> 
> 
> cleanEx()
> nameEx("PPC-discrete")
> ### * PPC-discrete
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-discrete
> ### Title: PPCs for discrete outcomes
> ### Aliases: PPC-discrete ppc_bars ppc_bars_grouped ppc_rootogram
> ###   ppc_bars_data
> 
> ### ** Examples
> 
> set.seed(9222017)
> 
> # bar plots
> f <- function(N) {
+   sample(1:4, size = N, replace = TRUE, prob = c(0.25, 0.4, 0.1, 0.25))
+ }
> y <- f(100)
> yrep <- t(replicate(500, f(100)))
> dim(yrep)
[1] 500 100
> group <- gl(2, 50, length = 100, labels = c("GroupA", "GroupB"))
> 
> color_scheme_set("mix-pink-blue")
> ppc_bars(y, yrep)
> 
> # split by group, change interval width, and display proportion
> # instead of count on y-axis
> color_scheme_set("mix-blue-pink")
> ppc_bars_grouped(y, yrep, group, prob = 0.5, freq = FALSE)
> 
> ## Not run: 
> ##D # example for ordinal regression using rstanarm
> ##D library(rstanarm)
> ##D fit <- stan_polr(
> ##D   tobgp ~ agegp,
> ##D   data = esoph,
> ##D   method = "probit",
> ##D   prior = R2(0.2, "mean"),
> ##D   init_r = 0.1,
> ##D   seed = 12345,
> ##D   # cores = 4,
> ##D   refresh = 0
> ##D  )
> ##D 
> ##D # coded as character, so convert to integer
> ##D yrep_char <- posterior_predict(fit)
> ##D print(yrep_char[1, 1:4])
> ##D 
> ##D yrep_int <- sapply(data.frame(yrep_char, stringsAsFactors = TRUE), as.integer)
> ##D y_int <- as.integer(esoph$tobgp)
> ##D 
> ##D ppc_bars(y_int, yrep_int)
> ##D 
> ##D ppc_bars_grouped(
> ##D   y = y_int,
> ##D   yrep = yrep_int,
> ##D   group = esoph$agegp,
> ##D   freq=FALSE,
> ##D   prob = 0.5,
> ##D   fatten = 1,
> ##D   size = 1.5
> ##D )
> ## End(Not run)
> 
> # rootograms for counts
> y <- rpois(100, 20)
> yrep <- matrix(rpois(10000, 20), ncol = 100)
> 
> color_scheme_set("brightblue")
> ppc_rootogram(y, yrep)
> ppc_rootogram(y, yrep, prob = 0)
> 
> ppc_rootogram(y, yrep, style = "hanging", prob = 0.8)
> ppc_rootogram(y, yrep, style = "suspended")
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-distributions")
> ### * PPC-distributions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-distributions
> ### Title: PPC distributions
> ### Aliases: PPC-distributions ppc_data ppc_dens_overlay
> ###   ppc_dens_overlay_grouped ppc_ecdf_overlay ppc_ecdf_overlay_grouped
> ###   ppc_dens ppc_hist ppc_freqpoly ppc_freqpoly_grouped ppc_boxplot
> ###   ppc_violin_grouped ppc_pit_ecdf ppc_pit_ecdf_grouped
> 
> ### ** Examples
> 
> color_scheme_set("brightblue")
> y <- example_y_data()
> yrep <- example_yrep_draws()
> group <- example_group_data()
> dim(yrep)
[1] 500 434
> 
> ppc_dens_overlay(y, yrep[1:25, ])
> 
> # for ppc_hist,dens,freqpoly,boxplot definitely use a subset yrep rows so
> # only a few (instead of nrow(yrep)) histograms are plotted
> ppc_hist(y, yrep[1:8, ])
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> 
> # density and distribution overlays by group
> ppc_dens_overlay_grouped(y, yrep[1:25, ], group = group)
> 
> ppc_ecdf_overlay_grouped(y, yrep[1:25, ], group = group)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-errors")
> ### * PPC-errors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-errors
> ### Title: PPC errors
> ### Aliases: PPC-errors ppc_error_hist ppc_error_hist_grouped
> ###   ppc_error_scatter ppc_error_scatter_avg ppc_error_scatter_avg_grouped
> ###   ppc_error_scatter_avg_vs_x ppc_error_binned ppc_error_data
> 
> ### ** Examples
> 
> y <- example_y_data()
> yrep <- example_yrep_draws()
> ppc_error_hist(y, yrep[1:3, ])
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # errors within groups
> group <- example_group_data()
> (p1 <- ppc_error_hist_grouped(y, yrep[1:3, ], group))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> p1 + yaxis_text() # defaults to showing counts on y-axis
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # scatterplots
> ppc_error_scatter(y, yrep[10:14, ])
> ppc_error_scatter_avg(y, yrep)
> 
> x <- example_x_data()
> ppc_error_scatter_avg_vs_x(y, yrep, x)
> 
> ## Not run: 
> ##D # binned error plot with binomial model from rstanarm
> ##D library(rstanarm)
> ##D example("example_model", package = "rstanarm")
> ##D formula(example_model)
> ##D 
> ##D # get observed proportion of "successes"
> ##D y <- example_model$y  # matrix of "success" and "failure" counts
> ##D trials <- rowSums(y)
> ##D y_prop <- y[, 1] / trials  # proportions
> ##D 
> ##D # get predicted success proportions
> ##D yrep <- posterior_predict(example_model)
> ##D yrep_prop <- sweep(yrep, 2, trials, "/")
> ##D 
> ##D ppc_error_binned(y_prop, yrep_prop[1:6, ])
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-intervals")
> ### * PPC-intervals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-intervals
> ### Title: PPC intervals
> ### Aliases: PPC-intervals ppc_intervals ppc_intervals_grouped ppc_ribbon
> ###   ppc_ribbon_grouped ppc_intervals_data ppc_ribbon_data
> 
> ### ** Examples
> 
> y <- rnorm(50)
> yrep <- matrix(rnorm(5000, 0, 2), ncol = 50)
> 
> color_scheme_set("brightblue")
> ppc_intervals(y, yrep)
> ppc_ribbon(y, yrep)
> ppc_ribbon(y, yrep, y_draw = "points")
> ## Not run: 
> ##D ppc_ribbon(y, yrep, y_draw = "both")
> ## End(Not run)
> 
> ppc_intervals(y, yrep, size = 1.5, fatten = 0) # remove the yrep point estimates
> 
> color_scheme_set("teal")
> year <- 1950:1999
> ppc_intervals(y, yrep, x = year, fatten = 1) + ggplot2::xlab("Year")
> ppc_ribbon(y, yrep, x = year) + ggplot2::xlab("Year")
> 
> color_scheme_set("pink")
> year <- rep(2000:2009, each = 5)
> group <- gl(5, 1, length = 50, labels = LETTERS[1:5])
> ppc_ribbon_grouped(y, yrep, x = year, group, y_draw = "both") +
+   ggplot2::scale_x_continuous(breaks = pretty)
> 
> ppc_ribbon_grouped(y, yrep, x = year, group,
+                    facet_args = list(scales = "fixed")) +
+  xaxis_text(FALSE) +
+  xaxis_ticks(FALSE) +
+  panel_bg(fill = "gray20")
> 
> # get the data frames used to make the ggplots
> ppc_dat <- ppc_intervals_data(y, yrep, x = year, prob = 0.5)
> ppc_group_dat <- ppc_intervals_data(y, yrep, x = year, group = group, prob = 0.5)
> 
> ## Not run: 
> ##D library("rstanarm")
> ##D fit <- stan_glmer(mpg ~ wt + (1|cyl), data = mtcars, refresh = 0)
> ##D yrep <- posterior_predict(fit)
> ##D 
> ##D color_scheme_set("purple")
> ##D ppc_intervals(y = mtcars$mpg, yrep = yrep, x = mtcars$wt, prob = 0.8) +
> ##D  panel_bg(fill="gray90", color = NA) +
> ##D  grid_lines(color = "white")
> ##D 
> ##D ppc_ribbon(y = mtcars$mpg, yrep = yrep, x = mtcars$wt,
> ##D            prob = 0.6, prob_outer = 0.8)
> ##D 
> ##D ppc_ribbon_grouped(y = mtcars$mpg, yrep = yrep, x = mtcars$wt,
> ##D                    group = mtcars$cyl)
> ##D 
> ##D 
> ##D color_scheme_set("gray")
> ##D ppc_intervals(mtcars$mpg, yrep, prob = 0.5) +
> ##D  ggplot2::scale_x_continuous(
> ##D    labels = rownames(mtcars),
> ##D    breaks = 1:nrow(mtcars)
> ##D  ) +
> ##D  xaxis_text(angle = -70, vjust = 1, hjust = 0) +
> ##D  xaxis_title(FALSE)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-loo")
> ### * PPC-loo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-loo
> ### Title: LOO predictive checks
> ### Aliases: PPC-loo ppc_loo_pit_overlay ppc_loo_pit_data ppc_loo_pit_qq
> ###   ppc_loo_pit ppc_loo_intervals ppc_loo_ribbon
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D library(rstanarm)
> ##D library(loo)
> ##D 
> ##D head(radon)
> ##D fit <- stan_lmer(
> ##D   log_radon ~ floor + log_uranium + floor:log_uranium
> ##D                + (1 + floor | county),
> ##D   data = radon,
> ##D   iter = 1000,
> ##D   chains = 2,
> ##D   cores = 2
> ##D  )
> ##D y <- radon$log_radon
> ##D yrep <- posterior_predict(fit)
> ##D 
> ##D loo1 <- loo(fit, save_psis = TRUE, cores = 4)
> ##D psis1 <- loo1$psis_object
> ##D lw <- weights(psis1) # normalized log weights
> ##D 
> ##D # marginal predictive check using LOO probability integral transform
> ##D color_scheme_set("orange")
> ##D ppc_loo_pit_overlay(y, yrep, lw = lw)
> ##D 
> ##D ppc_loo_pit_qq(y, yrep, lw = lw)
> ##D ppc_loo_pit_qq(y, yrep, lw = lw, compare = "normal")
> ##D 
> ##D 
> ##D # loo predictive intervals vs observations
> ##D keep_obs <- 1:50
> ##D ppc_loo_intervals(y, yrep, psis_object = psis1, subset = keep_obs)
> ##D 
> ##D color_scheme_set("gray")
> ##D ppc_loo_intervals(y, yrep, psis_object = psis1, subset = keep_obs,
> ##D                   order = "median")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-scatterplots")
> ### * PPC-scatterplots
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-scatterplots
> ### Title: PPC scatterplots
> ### Aliases: PPC-scatterplots ppc_scatter ppc_scatter_avg
> ###   ppc_scatter_avg_grouped ppc_scatter_data ppc_scatter_avg_data
> 
> ### ** Examples
> 
> y <- example_y_data()
> yrep <- example_yrep_draws()
> p1 <- ppc_scatter_avg(y, yrep)
> p1
> 
> # don't draw line x=y
> ppc_scatter_avg(y, yrep, ref_line = FALSE)
> 
> p2 <- ppc_scatter(y, yrep[20:23, ], alpha = 0.5, size = 1.5)
> p2
> 
> # give x and y axes the same limits
> lims <- ggplot2::lims(x = c(0, 160), y = c(0, 160))
> p1 + lims
> p2 + lims
Warning: Removed 1 rows containing missing values (`geom_point()`).
> 
> # for ppc_scatter_avg_grouped the default is to allow the facets
> # to have different x and y axes
> group <- example_group_data()
> ppc_scatter_avg_grouped(y, yrep, group)
> 
> # let x-axis vary but force y-axis to be the same
> ppc_scatter_avg_grouped(y, yrep, group, facet_args = list(scales = "free_x"))
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-test-statistics")
> ### * PPC-test-statistics
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-test-statistics
> ### Title: PPC test statistics
> ### Aliases: PPC-test-statistics PPC-statistics ppc_stat ppc_stat_grouped
> ###   ppc_stat_freqpoly ppc_stat_freqpoly_grouped ppc_stat_2d ppc_stat_data
> 
> ### ** Examples
> 
> y <- example_y_data()
> yrep <- example_yrep_draws()
> ppc_stat(y, yrep)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> ppc_stat(y, yrep, stat = "sd") + legend_none()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # use your own function for the 'stat' argument
> color_scheme_set("brightblue")
> q25 <- function(y) quantile(y, 0.25)
> ppc_stat(y, yrep, stat = "q25") # legend includes function name
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # can define the function in the 'stat' argument instead of
> # using its name but then the legend doesn't include the function name
> ppc_stat(y, yrep, stat = function(y) quantile(y, 0.25))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # plots by group
> color_scheme_set("teal")
> group <- example_group_data()
> ppc_stat_grouped(y, yrep, group)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> ppc_stat_grouped(y, yrep, group) + yaxis_text()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # force y-axes to have same scales, allow x axis to vary
> ppc_stat_grouped(y, yrep, group, facet_args = list(scales = "free_x")) + yaxis_text()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # the freqpoly plots use frequency polygons instead of histograms
> ppc_stat_freqpoly(y, yrep, stat = "median")
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> ppc_stat_freqpoly_grouped(y, yrep, group, stat = "median", facet_args = list(nrow = 2))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # ppc_stat_2d allows 2 statistics and makes a scatterplot
> bayesplot_theme_set(ggplot2::theme_linedraw())
> color_scheme_set("viridisE")
> ppc_stat_2d(y, yrep, stat = c("mean", "sd"))
> 
> bayesplot_theme_set(ggplot2::theme_grey())
> color_scheme_set("brewer-Paired")
> ppc_stat_2d(y, yrep, stat = c("median", "mad"))
> 
> # reset aesthetics
> color_scheme_set()
> bayesplot_theme_set()
> 
> 
> 
> 
> cleanEx()
> nameEx("PPD-distributions")
> ### * PPD-distributions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPD-distributions
> ### Title: PPD distributions
> ### Aliases: PPD-distributions ppd_data ppd_dens_overlay ppd_ecdf_overlay
> ###   ppd_dens ppd_hist ppd_freqpoly ppd_freqpoly_grouped ppd_boxplot
> 
> ### ** Examples
> 
> # difference between ppd_dens_overlay() and ppc_dens_overlay()
> color_scheme_set("brightblue")
> preds <- example_yrep_draws()
> ppd_dens_overlay(ypred = preds[1:50, ])
> ppc_dens_overlay(y = example_y_data(), yrep = preds[1:50, ])
> 
> 
> 
> 
> cleanEx()
> nameEx("PPD-intervals")
> ### * PPD-intervals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPD-intervals
> ### Title: PPD intervals
> ### Aliases: PPD-intervals ppd_intervals ppd_intervals_grouped ppd_ribbon
> ###   ppd_ribbon_grouped ppd_intervals_data ppd_ribbon_data
> 
> ### ** Examples
> 
> color_scheme_set("brightblue")
> ypred <- example_yrep_draws()
> x <- example_x_data()
> group <- example_group_data()
> 
> ppd_intervals(ypred[, 1:50])
> ppd_intervals(ypred[, 1:50], fatten = 0)
> ppd_intervals(ypred[, 1:50], fatten = 0, linewidth = 2)
> ppd_intervals(ypred[, 1:50], prob_outer = 0.75, fatten = 0, linewidth = 2)
> 
> # put a predictor variable on the x-axis
> ppd_intervals(ypred[, 1:100], x = x[1:100], fatten = 1) +
+   ggplot2::labs(y = "Prediction", x = "Some variable of interest")
> 
> # with a grouping variable too
> ppd_intervals_grouped(
+   ypred = ypred[, 1:100],
+   x = x[1:100],
+   group = group[1:100],
+   size = 2,
+   fatten = 0,
+   facet_args = list(nrow = 2)
+ )
> 
> # even reducing size, ppd_intervals is too cluttered when there are many
> # observations included (ppd_ribbon is better)
> ppd_intervals(ypred, size = 0.5, fatten = 0.1, linewidth = 0.5)
> ppd_ribbon(ypred)
> ppd_ribbon(ypred, size = 0) # remove line showing median prediction
> 
> 
> 
> 
> cleanEx()
> nameEx("PPD-test-statistics")
> ### * PPD-test-statistics
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPD-test-statistics
> ### Title: PPD test statistics
> ### Aliases: PPD-test-statistics PPD-statistics ppd_stat ppd_stat_grouped
> ###   ppd_stat_freqpoly ppd_stat_freqpoly_grouped ppd_stat_2d ppd_stat_data
> 
> ### ** Examples
> 
> yrep <- example_yrep_draws()
> ppd_stat(yrep)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> ppd_stat(yrep, stat = "sd") + legend_none()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # use your own function for the 'stat' argument
> color_scheme_set("brightblue")
> q25 <- function(y) quantile(y, 0.25)
> ppd_stat(yrep, stat = "q25") # legend includes function name
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> 
> 
> cleanEx()
> nameEx("available_ppc")
> ### * available_ppc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: available_ppc
> ### Title: Get or view the names of available plotting or data functions
> ### Aliases: available_ppc available_ppd available_mcmc
> 
> ### ** Examples
> 
> available_mcmc()
bayesplot MCMC module:
  mcmc_acf
  mcmc_acf_bar
  mcmc_areas
  mcmc_areas_ridges
  mcmc_combo
  mcmc_dens
  mcmc_dens_chains
  mcmc_dens_overlay
  mcmc_hex
  mcmc_hist
  mcmc_hist_by_chain
  mcmc_intervals
  mcmc_neff
  mcmc_neff_hist
  mcmc_nuts_acceptance
  mcmc_nuts_divergence
  mcmc_nuts_energy
  mcmc_nuts_stepsize
  mcmc_nuts_treedepth
  mcmc_pairs
  mcmc_parcoord
  mcmc_rank_ecdf
  mcmc_rank_hist
  mcmc_rank_overlay
  mcmc_recover_hist
  mcmc_recover_intervals
  mcmc_recover_scatter
  mcmc_rhat
  mcmc_rhat_hist
  mcmc_scatter
  mcmc_trace
  mcmc_trace_highlight
  mcmc_violin
> available_mcmc("nuts")
bayesplot MCMC module:
(matching pattern 'nuts') 
  mcmc_nuts_acceptance
  mcmc_nuts_divergence
  mcmc_nuts_energy
  mcmc_nuts_stepsize
  mcmc_nuts_treedepth
> available_mcmc("rhat|neff")
bayesplot MCMC module:
(matching pattern 'rhat|neff') 
  mcmc_neff
  mcmc_neff_hist
  mcmc_rhat
  mcmc_rhat_hist
> 
> available_ppc()
bayesplot PPC module:
  ppc_bars
  ppc_bars_grouped
  ppc_boxplot
  ppc_dens
  ppc_dens_overlay
  ppc_dens_overlay_grouped
  ppc_ecdf_overlay
  ppc_ecdf_overlay_grouped
  ppc_error_binned
  ppc_error_hist
  ppc_error_hist_grouped
  ppc_error_scatter
  ppc_error_scatter_avg
  ppc_error_scatter_avg_grouped
  ppc_error_scatter_avg_vs_x
  ppc_freqpoly
  ppc_freqpoly_grouped
  ppc_hist
  ppc_intervals
  ppc_intervals_grouped
  ppc_km_overlay
  ppc_km_overlay_grouped
  ppc_loo_intervals
  ppc_loo_pit
  ppc_loo_pit_overlay
  ppc_loo_pit_qq
  ppc_loo_ribbon
  ppc_pit_ecdf
  ppc_pit_ecdf_grouped
  ppc_ribbon
  ppc_ribbon_grouped
  ppc_rootogram
  ppc_scatter
  ppc_scatter_avg
  ppc_scatter_avg_grouped
  ppc_stat
  ppc_stat_2d
  ppc_stat_freqpoly
  ppc_stat_freqpoly_grouped
  ppc_stat_grouped
  ppc_violin_grouped
> available_ppc("grouped")
bayesplot PPC module:
(matching pattern 'grouped') 
  ppc_bars_grouped
  ppc_dens_overlay_grouped
  ppc_ecdf_overlay_grouped
  ppc_error_hist_grouped
  ppc_error_scatter_avg_grouped
  ppc_freqpoly_grouped
  ppc_intervals_grouped
  ppc_km_overlay_grouped
  ppc_pit_ecdf_grouped
  ppc_ribbon_grouped
  ppc_scatter_avg_grouped
  ppc_stat_freqpoly_grouped
  ppc_stat_grouped
  ppc_violin_grouped
> available_ppc("grouped", invert = TRUE)
bayesplot PPC module:
(excluding pattern 'grouped') 
  ppc_bars
  ppc_boxplot
  ppc_dens
  ppc_dens_overlay
  ppc_ecdf_overlay
  ppc_error_binned
  ppc_error_hist
  ppc_error_scatter
  ppc_error_scatter_avg
  ppc_error_scatter_avg_vs_x
  ppc_freqpoly
  ppc_hist
  ppc_intervals
  ppc_km_overlay
  ppc_loo_intervals
  ppc_loo_pit
  ppc_loo_pit_overlay
  ppc_loo_pit_qq
  ppc_loo_ribbon
  ppc_pit_ecdf
  ppc_ribbon
  ppc_rootogram
  ppc_scatter
  ppc_scatter_avg
  ppc_stat
  ppc_stat_2d
  ppc_stat_freqpoly
> 
> available_ppd()
bayesplot PPD module:
  ppd_boxplot
  ppd_dens
  ppd_dens_overlay
  ppd_ecdf_overlay
  ppd_freqpoly
  ppd_freqpoly_grouped
  ppd_hist
  ppd_intervals
  ppd_intervals_grouped
  ppd_ribbon
  ppd_ribbon_grouped
  ppd_stat
  ppd_stat_2d
  ppd_stat_freqpoly
  ppd_stat_freqpoly_grouped
  ppd_stat_grouped
> available_ppd("grouped")
bayesplot PPD module:
(matching pattern 'grouped') 
  ppd_freqpoly_grouped
  ppd_intervals_grouped
  ppd_ribbon_grouped
  ppd_stat_freqpoly_grouped
  ppd_stat_grouped
> 
> # can also see which functions that return data are available
> available_ppc(plots_only = FALSE)
bayesplot PPC module:
  ppc_bars
  ppc_bars_data
  ppc_bars_grouped
  ppc_boxplot
  ppc_data
  ppc_dens
  ppc_dens_overlay
  ppc_dens_overlay_grouped
  ppc_ecdf_overlay
  ppc_ecdf_overlay_grouped
  ppc_error_binned
  ppc_error_data
  ppc_error_hist
  ppc_error_hist_grouped
  ppc_error_scatter
  ppc_error_scatter_avg
  ppc_error_scatter_avg_grouped
  ppc_error_scatter_avg_vs_x
  ppc_freqpoly
  ppc_freqpoly_grouped
  ppc_hist
  ppc_intervals
  ppc_intervals_data
  ppc_intervals_grouped
  ppc_km_overlay
  ppc_km_overlay_grouped
  ppc_loo_intervals
  ppc_loo_pit
  ppc_loo_pit_data
  ppc_loo_pit_overlay
  ppc_loo_pit_qq
  ppc_loo_ribbon
  ppc_pit_ecdf
  ppc_pit_ecdf_grouped
  ppc_ribbon
  ppc_ribbon_data
  ppc_ribbon_grouped
  ppc_rootogram
  ppc_scatter
  ppc_scatter_avg
  ppc_scatter_avg_data
  ppc_scatter_avg_grouped
  ppc_scatter_data
  ppc_stat
  ppc_stat_2d
  ppc_stat_data
  ppc_stat_freqpoly
  ppc_stat_freqpoly_grouped
  ppc_stat_grouped
  ppc_violin_grouped
> 
> # only show the _data functions
> available_ppc("_data", plots_only = FALSE)
bayesplot PPC module:
(matching pattern '_data') 
  ppc_bars_data
  ppc_data
  ppc_error_data
  ppc_intervals_data
  ppc_loo_pit_data
  ppc_ribbon_data
  ppc_scatter_avg_data
  ppc_scatter_data
  ppc_stat_data
> available_ppd("_data", plots_only = FALSE)
bayesplot PPD module:
(matching pattern '_data') 
  ppd_data
  ppd_intervals_data
  ppd_ribbon_data
  ppd_stat_data
> available_mcmc("_data", plots_only = FALSE)
bayesplot MCMC module:
(matching pattern '_data') 
  mcmc_areas_data
  mcmc_areas_ridges_data
  mcmc_dens_chains_data
  mcmc_intervals_data
  mcmc_neff_data
  mcmc_parcoord_data
  mcmc_rhat_data
  mcmc_trace_data
> 
> 
> 
> 
> cleanEx()
> nameEx("bayesplot-colors")
> ### * bayesplot-colors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayesplot-colors
> ### Title: Set, get, or view *bayesplot* color schemes
> ### Aliases: bayesplot-colors color_scheme_set color_scheme_get
> ###   color_scheme_view
> 
> ### ** Examples
> 
> color_scheme_set("blue")
> color_scheme_view()
> 
> color_scheme_get()
     blue
1 #d1e1ec
2 #b3cde0
3 #6497b1
4 #005b96
5 #03396c
6 #011f4b
> color_scheme_get(i = c(3, 5)) # 3rd and 5th colors only
$mid
[1] "#6497b1"

$dark
[1] "#03396c"

> 
> color_scheme_get("brightblue")
  brightblue
1    #cce5ff
2    #99cbff
3    #4ca5ff
4    #198bff
5    #0065cc
6    #004c99
> color_scheme_view("brightblue")
> 
> # compare multiple schemes
> color_scheme_view(c("pink", "gray", "teal"))
> color_scheme_view(c("viridis", "viridisA", "viridisB", "viridisC"))
> 
> color_scheme_set("pink")
> x <- example_mcmc_draws()
> mcmc_intervals(x)
> 
> color_scheme_set("teal")
> color_scheme_view()
> mcmc_intervals(x)
> 
> color_scheme_set("red")
> mcmc_areas(x, regex_pars = "beta")
> 
> color_scheme_set("purple")
> color_scheme_view()
> y <- example_y_data()
> yrep <- example_yrep_draws()
> ppc_stat(y, yrep, stat = "mean") + legend_none()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> ############################
> ### Mixing color schemes ###
> ############################
> color_scheme_set("mix-teal-pink")
> ppc_stat(y, yrep, stat = "sd") + legend_none()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> mcmc_areas(x, regex_pars = "beta")
> 
> ##########################
> ### ColorBrewer scheme ###
> ##########################
> color_scheme_set("brewer-Spectral")
> color_scheme_view()
> mcmc_trace(x, pars = "sigma")
> 
> ###########################
> ### Custom color scheme ###
> ###########################
> orange_scheme <- c("#ffebcc", "#ffcc80",
+                    "#ffad33", "#e68a00",
+                    "#995c00", "#663d00")
> color_scheme_set(orange_scheme)
> color_scheme_view()
> mcmc_areas(x, regex_pars = "alpha")
> mcmc_dens_overlay(x)
> ppc_stat(y, yrep, stat = "var") + legend_none()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> 
> 
> 
> cleanEx()
> nameEx("bayesplot-extractors")
> ### * bayesplot-extractors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayesplot-extractors
> ### Title: Extract quantities needed for plotting from model objects
> ### Aliases: bayesplot-extractors log_posterior nuts_params rhat neff_ratio
> ###   log_posterior.stanfit log_posterior.stanreg log_posterior.CmdStanMCMC
> ###   nuts_params.stanfit nuts_params.stanreg nuts_params.list
> ###   nuts_params.CmdStanMCMC rhat.stanfit rhat.stanreg rhat.CmdStanMCMC
> ###   neff_ratio.stanfit neff_ratio.stanreg neff_ratio.CmdStanMCMC
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(rstanarm)
> ##D fit <- stan_glm(mpg ~ wt, data = mtcars, refresh = 0)
> ##D 
> ##D np <- nuts_params(fit)
> ##D head(np)
> ##D tail(np)
> ##D 
> ##D lp <- log_posterior(fit)
> ##D head(lp)
> ##D tail(lp)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("bayesplot-helpers")
> ### * bayesplot-helpers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayesplot-helpers
> ### Title: Convenience functions for adding or changing plot details
> ### Aliases: bayesplot-helpers vline_at hline_at vline_0 hline_0 abline_01
> ###   lbub legend_move legend_none legend_text xaxis_title xaxis_text
> ###   xaxis_ticks yaxis_title yaxis_text yaxis_ticks facet_text facet_bg
> ###   panel_bg plot_bg grid_lines overlay_function
> 
> ### ** Examples
> 
> color_scheme_set("gray")
> x <- example_mcmc_draws(chains = 1)
> dim(x)
[1] 250   4
> colnames(x)
[1] "alpha"   "sigma"   "beta[1]" "beta[2]"
> 
> 
> ###################################
> ### vertical & horizontal lines ###
> ###################################
> (p <- mcmc_intervals(x, regex_pars = "beta"))
> 
> # vertical line at zero (with some optional styling)
> p + vline_0()
> p + vline_0(linewidth = 0.25, color = "darkgray", linetype = 2)
> 
> # vertical line(s) at specified values
> v <- c(-0.5, 0, 0.5)
> p + vline_at(v, linetype = 3, linewidth = 0.25)
> 
> my_lines <- vline_at(v, alpha = 0.25, linewidth = 0.75 * c(1, 2, 1),
+                      color = c("maroon", "skyblue", "violet"))
> p + my_lines
> 
> 
> # using the lbub function to get interval lower and upper bounds (lb, ub)
> color_scheme_set("pink")
> parsed <- ggplot2::label_parsed
> p2 <- mcmc_hist(x, pars = "beta[1]", binwidth = 1/20,
+                 facet_args = list(labeller = parsed))
> (p2 <- p2 + facet_text(size = 16))
> 
> b1 <- x[, "beta[1]"]
> p2 + vline_at(b1, fun = lbub(0.8), color = "gray20",
+               linewidth = 2 * c(1,.5,1), alpha = 0.75)
> p2 + vline_at(b1, lbub(0.8, med = FALSE), color = "gray20",
+               linewidth = 2, alpha = 0.75)
> 
> 
> ##########################
> ### format axis titles ###
> ##########################
> color_scheme_set("green")
> y <- example_y_data()
> yrep <- example_yrep_draws()
> (p3 <- ppc_stat(y, yrep, stat = "median", binwidth = 1/4))
> 
> # turn off the legend, turn on x-axis title
> p3 +
+  legend_none() +
+  xaxis_title(size = 13, family = "sans") +
+  ggplot2::xlab(expression(italic(T(y)) == median(italic(y))))
> 
> 
> ################################
> ### format axis & facet text ###
> ################################
> color_scheme_set("gray")
> p4 <- mcmc_trace(example_mcmc_draws(), pars = c("alpha", "sigma"))
> 
> myfacets <-
+  facet_bg(fill = "gray30", color = NA) +
+  facet_text(face = "bold", color = "skyblue", size = 14)
> p4 + myfacets
> 
> 
> ##############################
> ### change plot background ###
> ##############################
> color_scheme_set("blue")
> 
> # add grid lines
> ppc_stat(y, yrep) + grid_lines()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # panel_bg vs plot_bg
> ppc_scatter_avg(y, yrep) + panel_bg(fill = "gray90")
> ppc_scatter_avg(y, yrep) + plot_bg(fill = "gray90")
> 
> color_scheme_set("yellow")
> p5 <- ppc_scatter_avg(y, yrep, alpha = 1)
> p5 + panel_bg(fill = "gray20") + grid_lines(color = "white")
> 
> 
> ###############################################
> ### superimpose a function on existing plot ###
> ###############################################
> # compare posterior of beta[1] to Gaussian with same posterior mean
> # and sd as beta[1]
> x <- example_mcmc_draws(chains = 4)
> dim(x)
[1] 250   4   4
> purple_gaussian <-
+   overlay_function(
+     fun = dnorm,
+     args = list(mean(x[,, "beta[1]"]), sd(x[,, "beta[1]"])),
+     color = "purple",
+     linewidth = 2
+   )
> 
> color_scheme_set("gray")
> mcmc_hist(x, pars = "beta[1]", freq = FALSE) + purple_gaussian
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> 
> 
> 
> cleanEx()
> nameEx("bayesplot-package")
> ### * bayesplot-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayesplot-package
> ### Title: *bayesplot*: Plotting for Bayesian Models
> ### Aliases: bayesplot-package bayesplot
> 
> ### ** Examples
> 
> # A few quick examples (all of the functions have many examples
> # on their individual help pages)
> 
> # MCMC plots
> x <- example_mcmc_draws(params = 5)
> mcmc_intervals(x, prob = 0.5)
> mcmc_intervals(x, regex_pars = "beta")
> 
> color_scheme_set("purple")
> mcmc_areas(x, regex_pars = "beta", prob = 0.8)
> 
> color_scheme_set("mix-blue-red")
> mcmc_trace(x, pars = c("alpha", "sigma"),
+            facet_args = list(nrow = 2))
> 
> color_scheme_set("brightblue")
> mcmc_scatter(x, pars = c("beta[1]", "sigma"),
+              transformations = list(sigma = "log"))
> 
> 
> # Graphical PPCs
> y <- example_y_data()
> yrep <- example_yrep_draws()
> ppc_dens_overlay(y, yrep[1:50, ])
> 
> 
> 
> 
> cleanEx()
> nameEx("bayesplot_grid")
> ### * bayesplot_grid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayesplot_grid
> ### Title: Arrange plots in a grid
> ### Aliases: bayesplot_grid
> 
> ### ** Examples
> 
> y <- example_y_data()
> yrep <- example_yrep_draws()
> stats <- c("sd", "median", "max", "min")
> 
> color_scheme_set("pink")
> bayesplot_grid(
+  plots = lapply(stats, function(s) ppc_stat(y, yrep, stat = s)),
+  titles = stats,
+  legends = FALSE,
+  grid_args = list(ncol = 1)
+ )
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> ## Not run: 
> ##D library(rstanarm)
> ##D mtcars$log_mpg <- log(mtcars$mpg)
> ##D fit1 <- stan_glm(mpg ~ wt, data = mtcars, refresh = 0)
> ##D fit2 <- stan_glm(log_mpg ~ wt, data = mtcars, refresh = 0)
> ##D 
> ##D y <- mtcars$mpg
> ##D yrep1 <- posterior_predict(fit1, draws = 50)
> ##D yrep2 <- posterior_predict(fit2, fun = exp, draws = 50)
> ##D 
> ##D color_scheme_set("blue")
> ##D ppc1 <- ppc_dens_overlay(y, yrep1)
> ##D ppc1
> ##D ppc1 + yaxis_text()
> ##D 
> ##D color_scheme_set("red")
> ##D ppc2 <- ppc_dens_overlay(y, yrep2)
> ##D bayesplot_grid(ppc1, ppc2)
> ##D 
> ##D # make sure the plots use the same limits for the axes
> ##D bayesplot_grid(ppc1, ppc2, xlim = c(-5, 60), ylim = c(0, 0.2))
> ##D 
> ##D # remove the legends and add text
> ##D bayesplot_grid(ppc1, ppc2, xlim = c(-5, 60), ylim = c(0, 0.2),
> ##D                legends = FALSE, subtitles = rep("Predicted MPG", 2))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("bayesplot_theme_get")
> ### * bayesplot_theme_get
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayesplot_theme_get
> ### Title: Get, set, and modify the active *bayesplot* theme
> ### Aliases: bayesplot_theme_get bayesplot_theme_set bayesplot_theme_update
> ###   bayesplot_theme_replace
> 
> ### ** Examples
> 
> library(ggplot2)
> 
> # plot using the current value of bayesplot_theme_get()
> # (the default is bayesplot::theme_default())
> x <- example_mcmc_draws()
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # change the bayesplot theme to theme_minimal and save the old theme
> old <- bayesplot_theme_set(theme_minimal())
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # change back to the previous theme
> bayesplot_theme_set(old)
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # change the default font size and family for bayesplots
> bayesplot_theme_update(text = element_text(size = 16, family = "sans"))
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # change back to the default
> bayesplot_theme_set() # same as bayesplot_theme_set(theme_default())
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # updating theme elements
> color_scheme_set("brightblue")
> bayesplot_theme_set(theme_dark())
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> bayesplot_theme_update(panel.background = element_rect(fill = "black"))
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # to get the same plot without updating the theme we could also have
> # used the bayeplot convenience function panel_bg()
> bayesplot_theme_set(theme_dark())
> mcmc_hist(x) + panel_bg(fill = "black")
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # reset
> bayesplot_theme_set()
> 
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’

> nameEx("example-data")
> ### * example-data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: example-data
> ### Title: Example draws to use in demonstrations and tests
> ### Aliases: example-data example_mcmc_draws example_yrep_draws
> ###   example_y_data example_x_data example_group_data
> ### Keywords: internal
> 
> ### ** Examples
> 
> draws <- example_mcmc_draws()
> dim(draws)
[1] 250   4   4
> dimnames(draws)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]"

> 
> draws <- example_mcmc_draws(1, 2)
> dim(draws)
[1] 250   2
> colnames(draws)
[1] "alpha" "sigma"
> 
> draws <- example_mcmc_draws(params = 6)
> dimnames(draws)[[3]]
[1] "alpha"   "sigma"   "beta[1]" "beta[2]" "beta[3]" "beta[4]"
> 
> y <- example_y_data()
> x <- example_x_data()
> group <- example_group_data()
> length(y)
[1] 434
> length(x)
[1] 434
> length(group)
[1] 434
> tail(data.frame(y, x, group), 5)
     y        x  group
430 94 84.87741 GroupA
431 76 92.99039 GroupB
432 50 94.85971 GroupA
433 88 96.85662 GroupB
434 70 91.25334 GroupB
> 
> yrep <- example_yrep_draws()
> dim(yrep) # ncol(yrep) = length(y) = length(x) = length(group)
[1] 500 434
> 
> 
> 
> 
> cleanEx()
> nameEx("pp_check")
> ### * pp_check
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pp_check
> ### Title: Posterior (or prior) predictive checks (S3 generic and default
> ###   method)
> ### Aliases: pp_check pp_check.default
> 
> ### ** Examples
> 
> # default method
> y <- example_y_data()
> yrep <- example_yrep_draws()
> pp_check(y, yrep[1:50,], ppc_dens_overlay)
> 
> g <- example_group_data()
> pp_check(y, yrep, fun = "stat_grouped", group = g, stat = "median")
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # defining a method
> x <- list(y = rnorm(50), yrep = matrix(rnorm(5000), nrow = 100, ncol = 50))
> class(x) <- "foo"
> pp_check.foo <- function(object, ..., type = c("multiple", "overlaid")) {
+   y <- object[["y"]]
+   yrep <- object[["yrep"]]
+   switch(match.arg(type),
+          multiple = ppc_hist(y, yrep[1:min(8, nrow(yrep)),, drop = FALSE]),
+          overlaid = ppc_dens_overlay(y, yrep))
+ }
> pp_check(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> pp_check(x, type = "overlaid")
> 
> 
> 
> 
> cleanEx()
> nameEx("theme_default")
> ### * theme_default
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: theme_default
> ### Title: Default *bayesplot* plotting theme
> ### Aliases: theme_default
> 
> ### ** Examples
> 
> class(theme_default())
[1] "theme" "gg"   
> 
> bayesplot_theme_set() # defaults to setting theme_default()
> x <- example_mcmc_draws()
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # change the default font size and family for bayesplots
> bayesplot_theme_set(theme_default(base_size = 8, base_family = "sans"))
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> mcmc_areas(x, regex_pars = "beta")
> 
> # change back
> bayesplot_theme_set()
> mcmc_areas(x, regex_pars = "beta")
> 
> 
> 
> 
> cleanEx()
> nameEx("tidy-params")
> ### * tidy-params
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tidy-params
> ### Title: Tidy parameter selection
> ### Aliases: tidy-params param_range param_glue
> 
> ### ** Examples
> 
> x <- example_mcmc_draws(params = 6)
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]" "beta[3]" "beta[4]"

> mcmc_hex(x, pars = vars(alpha, `beta[2]`))
> mcmc_dens(x, pars = vars(sigma, contains("beta")))
> mcmc_hist(x, pars = vars(-contains("beta")))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # using the param_range() helper
> mcmc_hist(x, pars = vars(param_range("beta", c(1, 3, 4))))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> ## Not run: 
> ##D ###################################
> ##D ## More examples of param_glue() ##
> ##D ###################################
> ##D library(dplyr)
> ##D posterior <- tibble(
> ##D   b_Intercept = rnorm(1000),
> ##D   sd_condition__Intercept = rexp(1000),
> ##D   sigma = rexp(1000),
> ##D   `r_condition[A,Intercept]` = rnorm(1000),
> ##D   `r_condition[B,Intercept]` = rnorm(1000),
> ##D   `r_condition[C,Intercept]` = rnorm(1000),
> ##D   `r_condition[A,Slope]` = rnorm(1000),
> ##D   `r_condition[B,Slope]` = rnorm(1000)
> ##D )
> ##D posterior
> ##D 
> ##D # using one expression in braces
> ##D posterior %>%
> ##D   select(
> ##D     param_glue("r_condition[{level},Intercept]", level = c("A", "B"))
> ##D   ) %>%
> ##D   mcmc_hist()
> ##D 
> ##D # using multiple expressions in braces
> ##D posterior %>%
> ##D    select(
> ##D      param_glue(
> ##D        "r_condition[{level},{type}]",
> ##D         level = c("A", "B"),
> ##D         type = c("Intercept", "Slope"))
> ##D    ) %>%
> ##D    mcmc_hist()
> ## End(Not run)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  21.563 0.464 22.823 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
